/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 2;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const TIME_UTC: u32 = 1;
pub const _UCHAR_H: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _BITS_WCTYPE_WCHAR_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGIOT: u32 = 6;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 6;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 0;
pub const _POSIX_OPEN_MAX: u32 = 16;
pub const _POSIX_FD_SETSIZE: u32 = 16;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 3;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _BYTESWAP_H: u32 = 1;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const SO_DEBUG: u32 = 1;
pub const SOL_SOCKET: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_BROADCAST: u32 = 6;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_ERROR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_LINGER: u32 = 13;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_RCVBUF: u32 = 8;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_SNDBUF: u32 = 7;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_SNDTIMEO: u32 = 21;
pub const SO_TYPE: u32 = 3;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_UNICAST_IF: u32 = 50;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const NCKEY_ESC: u32 = 27;
pub const NCKEY_SPACE: u32 = 32;
pub const CELL_ALPHA_HIGHCONTRAST: u32 = 805306368;
pub const CELL_ALPHA_TRANSPARENT: u32 = 536870912;
pub const CELL_ALPHA_BLEND: u32 = 268435456;
pub const CELL_ALPHA_OPAQUE: u32 = 0;
pub const CELL_BGDEFAULT_MASK: u32 = 1073741824;
pub const CELL_FGDEFAULT_MASK: u64 = 4611686018427387904;
pub const CELL_BG_RGB_MASK: u32 = 16777215;
pub const CELL_FG_RGB_MASK: u64 = 72057589742960640;
pub const CELL_BG_PALETTE: u32 = 134217728;
pub const NCPALETTESIZE: u32 = 256;
pub const CELL_FG_PALETTE: u64 = 576460752303423488;
pub const CELL_BG_ALPHA_MASK: u32 = 805306368;
pub const CELL_FG_ALPHA_MASK: u64 = 3458764513820540928;
pub const NCSTYLE_MASK: u32 = 1023;
pub const NCSTYLE_STANDOUT: u32 = 128;
pub const NCSTYLE_UNDERLINE: u32 = 64;
pub const NCSTYLE_REVERSE: u32 = 32;
pub const NCSTYLE_BLINK: u32 = 16;
pub const NCSTYLE_DIM: u32 = 8;
pub const NCSTYLE_BOLD: u32 = 4;
pub const NCSTYLE_INVIS: u32 = 2;
pub const NCSTYLE_PROTECT: u32 = 1;
pub const NCSTYLE_ITALIC: u32 = 256;
pub const NCSTYLE_STRUCK: u32 = 512;
pub const NCSTYLE_NONE: u32 = 0;
pub const NCOPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCOPTION_NO_CLEAR_BITMAPS: u32 = 2;
pub const NCOPTION_NO_WINCH_SIGHANDLER: u32 = 4;
pub const NCOPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCOPTION_SUPPRESS_BANNERS: u32 = 32;
pub const NCOPTION_NO_ALTERNATE_SCREEN: u32 = 64;
pub const NCOPTION_NO_FONT_CHANGES: u32 = 128;
pub const NCPLANE_OPTION_HORALIGNED: u32 = 1;
pub const NCPLANE_OPTION_VERALIGNED: u32 = 2;
pub const NCPLANE_OPTION_MARGINALIZED: u32 = 4;
pub const WCHAR_MAX_UTF8BYTES: u32 = 6;
pub const NCBOXMASK_TOP: u32 = 1;
pub const NCBOXMASK_RIGHT: u32 = 2;
pub const NCBOXMASK_BOTTOM: u32 = 4;
pub const NCBOXMASK_LEFT: u32 = 8;
pub const NCBOXGRAD_TOP: u32 = 16;
pub const NCBOXGRAD_RIGHT: u32 = 32;
pub const NCBOXGRAD_BOTTOM: u32 = 64;
pub const NCBOXGRAD_LEFT: u32 = 128;
pub const NCBOXCORNER_MASK: u32 = 768;
pub const NCBOXCORNER_SHIFT: u32 = 8;
pub const NCVISUAL_OPTION_NODEGRADE: u32 = 1;
pub const NCVISUAL_OPTION_BLEND: u32 = 2;
pub const NCVISUAL_OPTION_HORALIGNED: u32 = 4;
pub const NCVISUAL_OPTION_VERALIGNED: u32 = 8;
pub const NCREEL_OPTION_INFINITESCROLL: u32 = 1;
pub const NCREEL_OPTION_CIRCULAR: u32 = 2;
pub const PREFIXCOLUMNS: u32 = 7;
pub const IPREFIXCOLUMNS: u32 = 8;
pub const BPREFIXCOLUMNS: u32 = 9;
pub const PREFIXSTRLEN: u32 = 8;
pub const IPREFIXSTRLEN: u32 = 9;
pub const BPREFIXSTRLEN: u32 = 10;
pub const NCMENU_OPTION_BOTTOM: u32 = 1;
pub const NCMENU_OPTION_HIDING: u32 = 2;
pub const NCPROGBAR_OPTION_RETROGRADE: u32 = 1;
pub const NCTABBED_OPTION_BOTTOM: u32 = 1;
pub const NCPLOT_OPTION_LABELTICKSD: u32 = 1;
pub const NCPLOT_OPTION_EXPONENTIALD: u32 = 2;
pub const NCPLOT_OPTION_VERTICALI: u32 = 4;
pub const NCPLOT_OPTION_NODEGRADE: u32 = 8;
pub const NCPLOT_OPTION_DETECTMAXONLY: u32 = 16;
pub const NCPLOT_OPTION_PRINTSAMPLE: u32 = 32;
pub const NCREADER_OPTION_HORSCROLL: u32 = 1;
pub const NCREADER_OPTION_VERSCROLL: u32 = 2;
pub const NCREADER_OPTION_NOCMDKEYS: u32 = 4;
pub const NCREADER_OPTION_CURSOR: u32 = 8;
pub const NCDIRECT_OPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCDIRECT_OPTION_INHIBIT_CBREAK: u32 = 2;
pub const NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub type size_t = cty::c_ulong;
#[doc = " Convenience types."]
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
#[doc = " These few don't really vary by system, they always correspond"]
#[doc = "to one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,"]
#[doc = "even in the presence of asynchronous interrupts."]
#[doc = "It is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = cty::c_int;
extern "C" {
    #[doc = " Even though CLOCKS_PER_SEC has such a strange value CLK_TCK"]
    #[doc = "presents the real value for clock ticks per second for the system."]
    pub fn __sysconf(arg1: cty::c_int) -> cty::c_long;
}
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
#[doc = " Returned by `time'."]
pub type time_t = __time_t;
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: cty::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: cty::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: cty::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: cty::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: cty::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: cty::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: cty::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: cty::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: cty::c_int,
    #[doc = " Seconds east of UTC."]
    pub __tm_gmtoff: cty::c_long,
    #[doc = " Timezone abbreviation."]
    pub __tm_zone: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but"]
#[doc = "has nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    #[doc = " Time used by the program so far (user time + system time)."]
    #[doc = "The result / CLOCKS_PER_SEC is program time in seconds."]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[doc = " Return the current time and put it in *TIMER if TIMER is not NULL."]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[doc = " Return the difference between TIME1 and TIME0."]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[doc = " Return the `time_t' representation of TP and normalize TP."]
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT."]
    #[doc = "Write no more than MAXSIZE characters and return the number"]
    #[doc = "of characters written, or 0 if it would exceed MAXSIZE."]
    pub fn strftime(
        __s: *mut cty::c_char,
        __maxsize: size_t,
        __format: *const cty::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    #[doc = " Parse S according to FORMAT and store binary time information in TP."]
    #[doc = "The return value is a pointer to the first unparsed character in S."]
    pub fn strptime(
        __s: *const cty::c_char,
        __fmt: *const cty::c_char,
        __tp: *mut tm,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER"]
    #[doc = "in Universal Coordinated Time (aka Greenwich Mean Time)."]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation"]
    #[doc = "of *TIMER in the local timezone."]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in UTC,"]
    #[doc = "using *TP to store the result."]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in local time,"]
    #[doc = "using *TP to store the result."]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\""]
    #[doc = "that is the representation of TP in this format."]
    pub fn asctime(__tp: *const tm) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Equivalent to `asctime (localtime (timer))'."]
    pub fn ctime(__timer: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\""]
    #[doc = "that is the representation of TP in this format."]
    pub fn asctime_r(__tp: *const tm, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'."]
    pub fn ctime_r(__timer: *const time_t, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: cty::c_int;
}
extern "C" {
    pub static mut __timezone: cty::c_long;
}
extern "C" {
    pub static mut tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    #[doc = " Set time conversion information from the TZ environment variable."]
    #[doc = "If TZ is not defined, a locale-dependent default is used."]
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: cty::c_int;
}
extern "C" {
    pub static mut timezone: cty::c_long;
}
extern "C" {
    #[doc = " Set TS to calendar time based in time base BASE."]
    pub fn timespec_get(__ts: *mut timespec, __base: cty::c_int) -> cty::c_int;
}
#[doc = " Conversion state information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: cty::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: cty::c_uint,
    pub __wchb: [cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mbstate_t = __mbstate_t;
#[doc = " Define the 16-bit and 32-bit character types."]
pub type char16_t = __uint_least16_t;
pub type char32_t = __uint_least32_t;
extern "C" {
    #[doc = " Write char16_t representation of multibyte character pointed"]
    #[doc = "to by S to PC16."]
    pub fn mbrtoc16(
        __pc16: *mut char16_t,
        __s: *const cty::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Write multibyte representation of char16_t C16 to S."]
    pub fn c16rtomb(__s: *mut cty::c_char, __c16: char16_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    #[doc = " Write char32_t representation of multibyte character pointed"]
    #[doc = "to by S to PC32."]
    pub fn mbrtoc32(
        __pc32: *mut char32_t,
        __s: *const cty::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Write multibyte representation of char32_t C32 to S."]
    pub fn c32rtomb(__s: *mut cty::c_char, __c32: char32_t, __ps: *mut mbstate_t) -> size_t;
}
#[doc = " UPPERCASE."]
pub const _ISupper: cty::c_uint = 256;
#[doc = " lowercase."]
pub const _ISlower: cty::c_uint = 512;
#[doc = " Alphabetic."]
pub const _ISalpha: cty::c_uint = 1024;
#[doc = " Numeric."]
pub const _ISdigit: cty::c_uint = 2048;
#[doc = " Hexadecimal numeric."]
pub const _ISxdigit: cty::c_uint = 4096;
#[doc = " Whitespace."]
pub const _ISspace: cty::c_uint = 8192;
#[doc = " Printing."]
pub const _ISprint: cty::c_uint = 16384;
#[doc = " Graphical."]
pub const _ISgraph: cty::c_uint = 32768;
#[doc = " Blank (usually SPC and TAB)."]
pub const _ISblank: cty::c_uint = 1;
#[doc = " Control character."]
pub const _IScntrl: cty::c_uint = 2;
#[doc = " Punctuation."]
pub const _ISpunct: cty::c_uint = 4;
#[doc = " Alphanumeric."]
pub const _ISalnum: cty::c_uint = 8;
pub type _bindgen_ty_1 = cty::c_uint;
extern "C" {
    #[doc = " These are defined in ctype-info.c."]
    #[doc = "The declarations here must match those in localeinfo.h."]
    #[doc = ""]
    #[doc = "In the thread-specific locale model (see `uselocale' in <locale.h>)"]
    #[doc = "we cannot use global variables for these as was done in the past."]
    #[doc = "Instead, the following accessor functions return the address of"]
    #[doc = "each variable, which is local to the current thread if multithreaded."]
    #[doc = ""]
    #[doc = "These point into arrays of 384, so they can be indexed by any `unsigned"]
    #[doc = "char' value [0,255]; by EOF (-1); or by any `signed char' value"]
    #[doc = "[-128,-1).  ISO C requires that the ctype functions work for `unsigned"]
    #[doc = "char' values and for EOF; we also support negative `signed char' values"]
    #[doc = "for broken old programs.  The case conversion arrays are of `int's"]
    #[doc = "rather than `unsigned char's because tolower (EOF) must be EOF, which"]
    #[doc = "doesn't fit into an `unsigned char'.  But today more important is that"]
    #[doc = "the arrays are also used for multi-byte character sets."]
    pub fn __ctype_b_loc() -> *mut *const cty::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isalpha(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isdigit(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn islower(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isgraph(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isprint(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ispunct(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isspace(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isupper(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the lowercase version of C."]
    pub fn tolower(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the uppercase version of C."]
    pub fn toupper(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn isblank(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return nonzero iff C is in the ASCII set"]
    #[doc = "(i.e., is no more than 7 bits wide)."]
    pub fn isascii(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the part of C that is in the ASCII set"]
    #[doc = "(i.e., the low-order 7 bits of C)."]
    pub fn toascii(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _toupper(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _tolower(arg1: cty::c_int) -> cty::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = cty::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = cty::c_uint;
pub type __FILE = _IO_FILE;
#[doc = " Scalar type that can hold values which represent locale-specific"]
#[doc = "character classifications."]
pub type wctype_t = cty::c_ulong;
#[doc = " UPPERCASE."]
pub const __ISwupper: cty::c_int = 0;
#[doc = " lowercase."]
pub const __ISwlower: cty::c_int = 1;
#[doc = " Alphabetic."]
pub const __ISwalpha: cty::c_int = 2;
#[doc = " Numeric."]
pub const __ISwdigit: cty::c_int = 3;
#[doc = " Hexadecimal numeric."]
pub const __ISwxdigit: cty::c_int = 4;
#[doc = " Whitespace."]
pub const __ISwspace: cty::c_int = 5;
#[doc = " Printing."]
pub const __ISwprint: cty::c_int = 6;
#[doc = " Graphical."]
pub const __ISwgraph: cty::c_int = 7;
#[doc = " Blank (usually SPC and TAB)."]
pub const __ISwblank: cty::c_int = 8;
#[doc = " Control character."]
pub const __ISwcntrl: cty::c_int = 9;
#[doc = " Punctuation."]
pub const __ISwpunct: cty::c_int = 10;
#[doc = " Alphanumeric."]
pub const __ISwalnum: cty::c_int = 11;
#[doc = " UPPERCASE."]
pub const _ISwupper: cty::c_int = 16777216;
#[doc = " lowercase."]
pub const _ISwlower: cty::c_int = 33554432;
#[doc = " Alphabetic."]
pub const _ISwalpha: cty::c_int = 67108864;
#[doc = " Numeric."]
pub const _ISwdigit: cty::c_int = 134217728;
#[doc = " Hexadecimal numeric."]
pub const _ISwxdigit: cty::c_int = 268435456;
#[doc = " Whitespace."]
pub const _ISwspace: cty::c_int = 536870912;
#[doc = " Printing."]
pub const _ISwprint: cty::c_int = 1073741824;
#[doc = " Graphical."]
pub const _ISwgraph: cty::c_int = -2147483648;
#[doc = " Blank (usually SPC and TAB)."]
pub const _ISwblank: cty::c_int = 65536;
#[doc = " Control character."]
pub const _ISwcntrl: cty::c_int = 131072;
#[doc = " Punctuation."]
pub const _ISwpunct: cty::c_int = 262144;
#[doc = " Alphanumeric."]
pub const _ISwalnum: cty::c_int = 524288;
pub type _bindgen_ty_2 = cty::c_int;
extern "C" {
    #[doc = " Test for any wide character for which `iswalpha' or `iswdigit' is"]
    #[doc = "true."]
    pub fn iswalnum(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character for which `iswupper' or 'iswlower' is"]
    #[doc = "true, or any wide character that is one of a locale-specific set of"]
    #[doc = "wide-characters for which none of `iswcntrl', `iswdigit',"]
    #[doc = "`iswpunct', or `iswspace' is true."]
    pub fn iswalpha(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any control wide character."]
    pub fn iswcntrl(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a decimal-digit"]
    #[doc = "character."]
    pub fn iswdigit(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character for which `iswprint' is true and"]
    #[doc = "`iswspace' is false."]
    pub fn iswgraph(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a lowercase letter"]
    #[doc = "or is one of a locale-specific set of wide characters for which"]
    #[doc = "none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."]
    pub fn iswlower(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any printing wide character."]
    pub fn iswprint(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any printing wide character that is one of a"]
    #[doc = "locale-specific et of wide characters for which neither `iswspace'"]
    #[doc = "nor `iswalnum' is true."]
    pub fn iswpunct(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a locale-specific"]
    #[doc = "set of wide characters for which none of `iswalnum', `iswgraph', or"]
    #[doc = "`iswpunct' is true."]
    pub fn iswspace(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to an uppercase letter"]
    #[doc = "or is one of a locale-specific set of wide character for which none"]
    #[doc = "of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."]
    pub fn iswupper(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a hexadecimal-digit"]
    #[doc = "character equivalent to that performed be the functions described"]
    #[doc = "in the previous subclause."]
    pub fn iswxdigit(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    pub fn iswblank(__wc: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Construct value that describes a class of wide characters identified"]
    #[doc = "by the string argument PROPERTY."]
    pub fn wctype(__property: *const cty::c_char) -> wctype_t;
}
extern "C" {
    #[doc = " Determine whether the wide-character WC has the property described by"]
    #[doc = "DESC."]
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Converts an uppercase letter to the corresponding lowercase letter."]
    pub fn towlower(__wc: wint_t) -> wint_t;
}
extern "C" {
    #[doc = " Converts an lowercase letter to the corresponding uppercase letter."]
    pub fn towupper(__wc: wint_t) -> wint_t;
}
extern "C" {
    #[doc = " Copy SRC to DEST."]
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Copy no more than N wide-characters of SRC to DEST."]
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append SRC onto DEST."]
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append no more than N wide-characters of SRC onto DEST."]
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Compare S1 and S2."]
    pub fn wcscmp(__s1: *const cty::c_int, __s2: *const cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Compare N wide-characters of S1 and S2."]
    pub fn wcsncmp(
        __s1: *const cty::c_int,
        __s2: *const cty::c_int,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, both interpreted as appropriate to the"]
    #[doc = "LC_COLLATE category of the current locale."]
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Transform S2 into array pointed to by S1 such that if wcscmp is"]
    #[doc = "applied to two transformed strings the result is the as applying"]
    #[doc = "`wcscoll' to the original strings."]
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const cty::c_int, __wc: cty::c_int) -> *mut cty::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which"]
    #[doc = "consists entirely of wide characters not in REJECT."]
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> size_t;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which"]
    #[doc = "consists entirely of wide characters in  ACCEPT."]
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Divide WCS into tokens separated by characters in DELIM."]
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the number of wide characters in S."]
    pub fn wcslen(__s: *const cty::c_int) -> cty::c_ulong;
}
extern "C" {
    pub fn wcswcs(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemchr(__s: *const cty::c_int, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_int;
}
extern "C" {
    #[doc = " Compare N wide characters of S1 and S2."]
    pub fn wmemcmp(
        __s1: *const cty::c_int,
        __s2: *const cty::c_int,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST."]
    pub fn wmemcpy(
        __s1: *mut cty::c_int,
        __s2: *const cty::c_int,
        __n: cty::c_ulong,
    ) -> *mut cty::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST, guaranteeing"]
    #[doc = "correct behavior for overlapping strings."]
    pub fn wmemmove(
        __s1: *mut cty::c_int,
        __s2: *const cty::c_int,
        __n: cty::c_ulong,
    ) -> *mut cty::c_int;
}
extern "C" {
    #[doc = " Set N wide characters of S to C."]
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Determine whether C constitutes a valid (one-byte) multibyte"]
    #[doc = "character."]
    pub fn btowc(__c: cty::c_int) -> wint_t;
}
extern "C" {
    #[doc = " Determine whether C corresponds to a member of the extended"]
    #[doc = "character set whose multibyte representation is a single byte."]
    pub fn wctob(__c: wint_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Determine whether PS points to an object representing the initial"]
    #[doc = "state."]
    pub fn mbsinit(__ps: *const mbstate_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Write wide character representation of multibyte character pointed"]
    #[doc = "to by S to PWC."]
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const cty::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Write multibyte representation of wide character WC to S."]
    pub fn wcrtomb(__s: *mut cty::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    #[doc = " Return number of bytes in multibyte character pointed to by S."]
    pub fn __mbrlen(__s: *const cty::c_char, __n: size_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn mbrlen(__s: *const cty::c_char, __n: size_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    #[doc = " Write wide character representation of multibyte character string"]
    #[doc = "SRC to DST."]
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const cty::c_char,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Write multibyte character representation of wide character string"]
    #[doc = "SRC to DST."]
    pub fn wcsrtombs(
        __dst: *mut cty::c_char,
        __src: *mut *const wchar_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Determine number of column positions required for C."]
    pub fn wcwidth(__c: wchar_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Determine number of column positions required for first N wide"]
    #[doc = "characters (or fewer if S ends before this) in S."]
    pub fn wcswidth(__s: *const wchar_t, __n: size_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Convert initial portion of the wide string NPTR to `double'"]
    #[doc = "representation."]
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long int'"]
    #[doc = "representation."]
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long int'"]
    #[doc = "representation."]
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long long int'"]
    #[doc = "representation."]
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long long int'"]
    #[doc = "representation."]
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    #[doc = " Select orientation for stream."]
    pub fn fwide(__fp: *mut __FILE, __mode: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn wprintf(__format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output of at most N characters to S."]
    pub fn swprintf(__s: *mut wchar_t, __n: size_t, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output of at most N character to S from argument"]
    #[doc = "list ARG."]
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn wscanf(__format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM."]
    #[doc = ""]
    #[doc = "These functions are possible cancellation points and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Read a character from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn getwchar() -> wint_t;
}
extern "C" {
    #[doc = " Write a character to STREAM."]
    #[doc = ""]
    #[doc = "These functions are possible cancellation points and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Write a character to stdout."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    #[doc = " Get a newline-terminated wide character string of finite length"]
    #[doc = "from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fgetws(__ws: *mut wchar_t, __n: cty::c_int, __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Write a string to STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT."]
    #[doc = "Write no more than MAXSIZE wide characters and return the number"]
    #[doc = "of wide characters written, or 0 if it would exceed MAXSIZE."]
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: size_t,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> size_t;
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
pub type __fpos_t = _G_fpos_t;
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
pub type __fpos64_t = _G_fpos64_t;
#[doc = " The opaque type of streams.  This is the definition used elsewhere."]
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = cty::c_void;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic"]
#[doc = "C++ mangled names for functions taking FILE* arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: cty::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut cty::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut cty::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut cty::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut cty::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut cty::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut cty::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut cty::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut cty::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut cty::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut cty::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: cty::c_int,
    pub _flags2: cty::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: cty::c_ushort,
    pub _vtable_offset: cty::c_schar,
    pub _shortbuf: [cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    #[doc = " Wide character stream stuff."]
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut cty::c_void,
    pub __pad5: size_t,
    pub _mode: cty::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [cty::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    #[doc = " Remove file FILENAME."]
    pub fn remove(__filename: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Rename file OLD to NEW."]
    pub fn rename(__old: *const cty::c_char, __new: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[doc = " Generate a temporary filename."]
    pub fn tmpnam(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Generate a unique temporary filename using up to five characters of PFX"]
    #[doc = "if it is not NULL.  The directory to put this file in is searched for"]
    #[doc = "as follows: First the environment variable \"TMPDIR\" is checked."]
    #[doc = "If it contains the name of a writable directory, that directory is used."]
    #[doc = "If not and if DIR is not NULL, that value is checked.  If that fails,"]
    #[doc = "P_tmpdir is tried and finally \"/tmp\".  The storage for the filename"]
    #[doc = "is allocated by `malloc'."]
    pub fn tempnam(__dir: *const cty::c_char, __pfx: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Close STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Flush STREAM, or all streams if STREAM is NULL."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fflush(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Open a file and create a new stream for it."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fopen(__filename: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a file, replacing an existing stream with it."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn freopen(
        __filename: *const cty::c_char,
        __modes: *const cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to an existing system file descriptor."]
    pub fn fdopen(__fd: cty::c_int, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " If BUF is NULL, make STREAM unbuffered."]
    #[doc = "Else make it use buffer BUF, of size BUFSIZ."]
    pub fn setbuf(__stream: *mut FILE, __buf: *mut cty::c_char);
}
extern "C" {
    #[doc = " Make STREAM use buffering mode MODE."]
    #[doc = "If BUF is not NULL, use N bytes of it for buffering;"]
    #[doc = "else allocate an internal buffer N bytes long."]
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut cty::c_char,
        __modes: cty::c_int,
        __n: size_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fprintf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn printf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S."]
    pub fn sprintf(__s: *mut cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vprintf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    pub fn vsprintf(
        __s: *mut cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Maximum chars of output to write in MAXLEN."]
    pub fn snprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fscanf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn scanf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    pub fn sscanf(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn vscanf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vsscanf(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM."]
    #[doc = ""]
    #[doc = "These functions are possible cancellation points and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fgetc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Read a character from stdin."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    #[doc = " Write a character to STREAM."]
    #[doc = ""]
    #[doc = "These functions are possible cancellation points and therefore not"]
    #[doc = "marked with __THROW."]
    #[doc = ""]
    #[doc = "These functions is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fputc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a character to stdout."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn putchar(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get a word (int) from STREAM."]
    pub fn getw(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a word (int) to STREAM."]
    pub fn putw(__w: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Get a newline-terminated string of finite length from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fgets(__s: *mut cty::c_char, __n: cty::c_int, __stream: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Write a string to STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fputs(__s: *const cty::c_char, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a string, followed by a newline, to stdout."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn puts(__s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn ungetc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Read chunks of generic data from STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fread(
        __ptr: *mut cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __stream: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Write chunks of generic data to STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fwrite(
        __ptr: *const cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __s: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fseek(__stream: *mut FILE, __off: cty::c_long, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn ftell(__stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    #[doc = " Rewind to the beginning of STREAM."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Get STREAM's position."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Set STREAM's position."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Clear the error and EOF indicators for STREAM."]
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Return the EOF indicator for STREAM."]
    pub fn feof(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the error indicator for STREAM."]
    pub fn ferror(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Print a message describing the meaning of the value of errno."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn perror(__s: *const cty::c_char);
}
extern "C" {
    #[doc = " Return the system file descriptor for STREAM."]
    pub fn fileno(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Create a new stream connected to a pipe running the given command."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn popen(__command: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " Close a stream opened by popen and return the status of its child."]
    #[doc = ""]
    #[doc = "This function is a possible cancellation point and therefore not"]
    #[doc = "marked with __THROW."]
    pub fn pclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the name of the controlling terminal."]
    pub fn ctermid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Return the name of the current user."]
    pub fn cuserid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub static mut optarg: *mut cty::c_char;
}
extern "C" {
    pub static mut optind: cty::c_int;
}
extern "C" {
    pub static mut opterr: cty::c_int;
}
extern "C" {
    pub static mut optopt: cty::c_int;
}
extern "C" {
    #[doc = " Get definitions and prototypes for functions to process the"]
    #[doc = "arguments in ARGV (ARGC of them, minus the program name) for"]
    #[doc = "options given in OPTS."]
    #[doc = ""]
    #[doc = "Return the option character from OPTS just read.  Return -1 when"]
    #[doc = "there are no more options.  For unrecognized options, or options"]
    #[doc = "missing arguments, 'optopt' is set to the option letter, and '?' is"]
    #[doc = "returned."]
    #[doc = ""]
    #[doc = "The OPTS string is a list of characters which are recognized option"]
    #[doc = "letters, optionally followed by colons, specifying that that letter"]
    #[doc = "takes an argument, to be placed in 'optarg'."]
    #[doc = ""]
    #[doc = "If a letter in OPTS is followed by two colons, its argument is"]
    #[doc = "optional.  This behavior is specific to the GNU 'getopt'."]
    #[doc = ""]
    #[doc = "The argument '--' causes premature termination of argument"]
    #[doc = "scanning, explicitly telling 'getopt' that there are no more"]
    #[doc = "options."]
    #[doc = ""]
    #[doc = "If OPTS begins with '-', then non-option arguments are treated as"]
    #[doc = "arguments to the option '\\1'.  This behavior is specific to the GNU"]
    #[doc = "'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in"]
    #[doc = "the environment, then do not permute arguments."]
    #[doc = ""]
    #[doc = "For standards compliance, the 'argv' argument has the type"]
    #[doc = "char *const *, but this is inaccurate; if argument permutation is"]
    #[doc = "enabled, the argv array (not the strings it points to) must be"]
    #[doc = "writable."]
    pub fn getopt(
        ___argc: cty::c_int,
        ___argv: *const *mut cty::c_char,
        __shortopts: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Slow-path routines used by the optimized inline functions in"]
    #[doc = "bits/stdio.h."]
    pub fn __uflow(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: cty::c_int) -> cty::c_int;
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: cty::c_int,
    #[doc = " Remainder."]
    pub rem: cty::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: cty::c_long,
    #[doc = " Remainder."]
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: cty::c_longlong,
    #[doc = " Remainder."]
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn atof(__nptr: *const cty::c_char) -> f64;
}
extern "C" {
    #[doc = " Convert a string to an integer."]
    pub fn atoi(__nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn atol(__nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    #[doc = " Convert a string to a long long integer."]
    pub fn atoll(__nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn strtod(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn strtof(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn strtol(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    #[doc = " Convert a string to an unsigned long integer."]
    pub fn strtoul(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Convert a string to a quadword integer."]
    pub fn strtoll(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to an unsigned quadword integer."]
    pub fn strtoull(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    #[doc = " Return a random integer between 0 and RAND_MAX inclusive."]
    pub fn rand() -> cty::c_int;
}
extern "C" {
    #[doc = " Seed the random number generator with the given number."]
    pub fn srand(__seed: cty::c_uint);
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut cty::c_ushort) -> f64;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    #[doc = " Return signed, long integers in [-2^31,2^31)."]
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    #[doc = " Seed random number generator."]
    pub fn srand48(__seedval: cty::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut cty::c_ushort);
}
extern "C" {
    #[doc = " Allocate SIZE bytes of memory."]
    pub fn malloc(__size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Allocate NMEMB elements of SIZE bytes each, all initialized to 0."]
    pub fn calloc(__nmemb: cty::c_ulong, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block"]
    #[doc = "in PTR, making the new block SIZE bytes long.  */"]
    #[doc = "the same pointer that was passed to it, aliasing needs to be allowed"]
    #[doc = "between objects pointed by the old and new pointers."]
    pub fn realloc(__ptr: *mut cty::c_void, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Free a block allocated by `malloc', `realloc' or `calloc'."]
    pub fn free(__ptr: *mut cty::c_void);
}
extern "C" {
    #[doc = " ISO C variant of aligned allocation."]
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Abort execution and generate a core-dump."]
    pub fn abort();
}
extern "C" {
    #[doc = " Register a function to be called when `exit' is called."]
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    #[doc = " Call all functions registered with `atexit' and `on_exit',"]
    #[doc = "in the reverse of the order in which they were registered,"]
    #[doc = "perform stdio cleanup, and terminate program execution with STATUS."]
    pub fn exit(__status: cty::c_int);
}
extern "C" {
    #[doc = " Call all functions registered with `at_quick_exit' in the reverse"]
    #[doc = "of the order in which they were registered and terminate program"]
    #[doc = "execution with STATUS."]
    pub fn quick_exit(__status: cty::c_int);
}
extern "C" {
    #[doc = " Terminate the program with STATUS without calling any of the"]
    #[doc = "functions registered with `atexit' or `on_exit'."]
    pub fn _Exit(__status: cty::c_int);
}
extern "C" {
    #[doc = " Return the value of envariable NAME, or NULL if it doesn't exist."]
    pub fn getenv(__name: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " The SVID says this is in <stdio.h>, but this seems a better place.\t*/"]
    #[doc = "If there is no `=', remove NAME from the environment."]
    pub fn putenv(__string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Execute the given line as a shell command."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn system(__command: *const cty::c_char) -> cty::c_int;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    #[doc = " Do a binary search for KEY in BASE, which consists of NMEMB elements"]
    #[doc = "of SIZE bytes each, using COMPAR to perform the comparisons."]
    pub fn bsearch(
        __key: *const cty::c_void,
        __base: *const cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Sort NMEMB elements of BASE, of SIZE bytes each,"]
    #[doc = "using COMPAR to perform the comparisons."]
    pub fn qsort(
        __base: *mut cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    #[doc = " Return the absolute value of X."]
    pub fn abs(__x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn labs(__x: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn llabs(__x: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    #[doc = " Return the `div_t', `ldiv_t' or `lldiv_t' representation"]
    #[doc = "of the value of NUMER over DENOM. */"]
    pub fn div(__numer: cty::c_int, __denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: cty::c_long, __denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: cty::c_longlong, __denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    #[doc = " Return the length of the multibyte character"]
    #[doc = "in S, which is no longer than N."]
    pub fn mblen(__s: *const cty::c_char, __n: size_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the length of the given multibyte character,"]
    #[doc = "putting its `wchar_t' representation in *PWC."]
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const cty::c_char, __n: size_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Put the multibyte character represented"]
    #[doc = "by WCHAR in S, returning its length."]
    pub fn wctomb(__s: *mut cty::c_char, __wchar: wchar_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Convert a multibyte string to a wide char string."]
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const cty::c_char, __n: size_t) -> size_t;
}
extern "C" {
    #[doc = " Convert a wide char string to multibyte string."]
    pub fn wcstombs(__s: *mut cty::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    #[doc = " Copy N bytes of SRC to DEST."]
    pub fn memcpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Copy N bytes of SRC to DEST, guaranteeing"]
    #[doc = "correct behavior for overlapping strings."]
    pub fn memmove(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __c: cty::c_int,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Set N bytes of S to C."]
    pub fn memset(__s: *mut cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Compare N bytes of S1 and S2."]
    pub fn memcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(__s: *const cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Copy SRC to DEST."]
    pub fn strcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Copy no more than N characters of SRC to DEST."]
    pub fn strncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Append SRC onto DEST."]
    pub fn strcat(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Append no more than N characters from SRC onto DEST."]
    pub fn strncat(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Compare S1 and S2."]
    pub fn strcmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Compare N characters of S1 and S2."]
    pub fn strncmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compare the collated forms of S1 and S2."]
    pub fn strcoll(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Put a transformation of SRC into no more than N bytes of DEST."]
    pub fn strxfrm(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Return the length of the initial segment of S which"]
    #[doc = "consists entirely of characters not in REJECT."]
    pub fn strcspn(__s: *const cty::c_char, __reject: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Return the length of the initial segment of S which"]
    #[doc = "consists entirely of characters in ACCEPT."]
    pub fn strspn(__s: *const cty::c_char, __accept: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const cty::c_char, __accept: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const cty::c_char, __needle: *const cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Divide S into tokens separated by characters in DELIM."]
    pub fn strtok(__s: *mut cty::c_char, __delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Divide S into tokens separated by characters in DELIM.  Information"]
    #[doc = "passed between calls are stored in SAVE_PTR."]
    pub fn __strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Return the length of S."]
    pub fn strlen(__s: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    #[doc = " Return a string describing the meaning of the `errno' code in ERRNUM."]
    pub fn strerror(__errnum: cty::c_int) -> *mut cty::c_char;
}
#[doc = " An integral type that can be modified atomically, without the"]
#[doc = "possibility of a signal arriving in the middle of the operation."]
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [cty::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
#[doc = " Type of a signal handler."]
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>;
extern "C" {
    #[doc = " The X/Open definition of `signal' specifies the SVID semantic.  Use"]
    #[doc = "the additional function `sysv_signal' when X/Open compatibility is"]
    #[doc = "requested."]
    pub fn __sysv_signal(__sig: cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Raise signal SIG, i.e., send SIG to yourself."]
    pub fn raise(__sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Clear all signals from SET."]
    pub fn sigemptyset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Set all signals in SET."]
    pub fn sigfillset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Add SIGNO to SET."]
    pub fn sigaddset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Remove SIGNO from SET."]
    pub fn sigdelset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return 1 if SIGNO is in SET, 0 if not."]
    pub fn sigismember(__set: *const sigset_t, __signo: cty::c_int) -> cty::c_int;
}
#[doc = " Structure describing the action to be taken when a signal arrives."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    #[doc = " Additional set of signals to be blocked."]
    pub sa_mask: __sigset_t,
    #[doc = " Special flags."]
    pub sa_flags: cty::c_int,
    #[doc = " Restore handler."]
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    #[doc = " Get and/or change the set of blocked signals."]
    pub fn sigprocmask(
        __how: cty::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Change the set of blocked signals to SET,"]
    #[doc = "wait until a signal arrives, and restore the set of blocked signals."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn sigsuspend(__set: *const sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Get and/or set the action for signal SIG."]
    pub fn sigaction(
        __sig: cty::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Put in SET all signals that are blocked and waiting to be delivered."]
    pub fn sigpending(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Return number of available real-time signal with highest priority."]
    pub fn __libc_current_sigrtmin() -> cty::c_int;
}
extern "C" {
    #[doc = " Return number of available real-time signal with lowest priority."]
    pub fn __libc_current_sigrtmax() -> cty::c_int;
}
#[doc = " Structure for scatter/gather I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    #[doc = " Pointer to data."]
    pub iov_base: *mut cty::c_void,
    #[doc = " Length of data."]
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type key_t = __key_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = cty::c_long;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type socklen_t = __socklen_t;
#[doc = " Sequenced, reliable, connection-based"]
#[doc = "byte streams."]
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
#[doc = " Connectionless, unreliable datagrams"]
#[doc = "of fixed maximum length."]
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
#[doc = " Raw protocol interface."]
pub const __socket_type_SOCK_RAW: __socket_type = 3;
#[doc = " Reliably-delivered messages."]
pub const __socket_type_SOCK_RDM: __socket_type = 4;
#[doc = " Sequenced, reliable, connection-based,"]
#[doc = "datagrams of fixed maximum length."]
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
#[doc = " Datagram Congestion Control Protocol."]
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
#[doc = " Linux specific way of getting packets"]
#[doc = "at the dev level.  For writing rarp and"]
#[doc = "other similar things on the user level."]
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
#[doc = " Atomically set close-on-exec flag for the"]
#[doc = "new descriptor(s)."]
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
#[doc = " Atomically mark descriptor(s) as"]
#[doc = "non-blocking."]
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
#[doc = " Types of sockets."]
pub type __socket_type = cty::c_uint;
#[doc = " POSIX.1g specifies this type name for the `sa_family' member."]
pub type sa_family_t = cty::c_ushort;
#[doc = " Structure describing a generic socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    #[doc = " Address data."]
    pub sa_data: [cty::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [cty::c_char; 118usize],
    #[doc = " Force desired alignment."]
    pub __ss_align: cty::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Process out-of-band data."]
pub const MSG_OOB: cty::c_uint = 1;
#[doc = " Peek at incoming messages."]
pub const MSG_PEEK: cty::c_uint = 2;
#[doc = " Don't use local routing."]
pub const MSG_DONTROUTE: cty::c_uint = 4;
#[doc = " Control data lost before delivery."]
pub const MSG_CTRUNC: cty::c_uint = 8;
#[doc = " Supply or ask second address."]
pub const MSG_PROXY: cty::c_uint = 16;
pub const MSG_TRUNC: cty::c_uint = 32;
#[doc = " Nonblocking IO."]
pub const MSG_DONTWAIT: cty::c_uint = 64;
#[doc = " End of record."]
pub const MSG_EOR: cty::c_uint = 128;
#[doc = " Wait for a full request."]
pub const MSG_WAITALL: cty::c_uint = 256;
pub const MSG_FIN: cty::c_uint = 512;
pub const MSG_SYN: cty::c_uint = 1024;
#[doc = " Confirm path validity."]
pub const MSG_CONFIRM: cty::c_uint = 2048;
pub const MSG_RST: cty::c_uint = 4096;
#[doc = " Fetch message from error queue."]
pub const MSG_ERRQUEUE: cty::c_uint = 8192;
#[doc = " Do not generate SIGPIPE."]
pub const MSG_NOSIGNAL: cty::c_uint = 16384;
#[doc = " Sender will send more."]
pub const MSG_MORE: cty::c_uint = 32768;
#[doc = " Wait for at least one packet to return."]
pub const MSG_WAITFORONE: cty::c_uint = 65536;
#[doc = " sendmmsg: more messages coming."]
pub const MSG_BATCH: cty::c_uint = 262144;
#[doc = " Use user data in kernel path."]
pub const MSG_ZEROCOPY: cty::c_uint = 67108864;
#[doc = " Send data in TCP SYN."]
pub const MSG_FASTOPEN: cty::c_uint = 536870912;
#[doc = " Set close_on_exit for file"]
#[doc = "descriptor received through"]
#[doc = "SCM_RIGHTS."]
pub const MSG_CMSG_CLOEXEC: cty::c_uint = 1073741824;
#[doc = " Bits in the FLAGS argument to `send', `recv', et al."]
pub type _bindgen_ty_3 = cty::c_uint;
#[doc = " Structure describing messages sent by"]
#[doc = "`sendmsg' and received by `recvmsg'."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct msghdr {
    #[doc = " Address to send to/receive from."]
    pub msg_name: *mut cty::c_void,
    #[doc = " Length of address data."]
    pub msg_namelen: socklen_t,
    #[doc = " Vector of data to send/receive into."]
    pub msg_iov: *mut iovec,
    #[doc = " Number of elements in the vector."]
    pub msg_iovlen: size_t,
    #[doc = " Ancillary data (eg BSD filedesc passing)."]
    pub msg_control: *mut cty::c_void,
    #[doc = " Ancillary data buffer length."]
    #[doc = " The type should be socklen_t but the"]
    #[doc = "definition of the kernel is incompatible"]
    #[doc = "with this."]
    pub msg_controllen: size_t,
    #[doc = " Flags on received message."]
    pub msg_flags: cty::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::core::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Structure used for storage of ancillary data object information."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    #[doc = " Length of data in cmsg_data plus length"]
    #[doc = "of cmsghdr structure."]
    #[doc = " The type should be socklen_t but the"]
    #[doc = "definition of the kernel is incompatible"]
    #[doc = "with this."]
    pub cmsg_len: size_t,
    #[doc = " Originating protocol."]
    pub cmsg_level: cty::c_int,
    #[doc = " Protocol specific type."]
    pub cmsg_type: cty::c_int,
    #[doc = " Ancillary data."]
    pub __cmsg_data: __IncompleteArrayField<cty::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::core::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
#[doc = " Transfer file descriptors."]
pub const SCM_RIGHTS: cty::c_uint = 1;
#[doc = " Socket level message types.  This must match the definitions in"]
#[doc = "<linux/socket.h>."]
pub type _bindgen_ty_4 = cty::c_uint;
#[doc = " Structure used to manipulate the SO_LINGER option."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linger {
    #[doc = " Nonzero to linger on close."]
    pub l_onoff: cty::c_int,
    #[doc = " Time to linger."]
    pub l_linger: cty::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::core::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::core::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[doc = " No more receptions."]
pub const SHUT_RD: cty::c_uint = 0;
#[doc = " No more transmissions."]
pub const SHUT_WR: cty::c_uint = 1;
#[doc = " No more receptions or transmissions."]
pub const SHUT_RDWR: cty::c_uint = 2;
#[doc = " The following constants should be used for the second parameter of"]
#[doc = "`shutdown'."]
pub type _bindgen_ty_5 = cty::c_uint;
extern "C" {
    #[doc = " Create a new socket of type TYPE in domain DOMAIN, using"]
    #[doc = "protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically."]
    #[doc = "Returns a file descriptor for the new socket, or -1 for errors."]
    pub fn socket(__domain: cty::c_int, __type: cty::c_int, __protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Create two new sockets, of type TYPE in domain DOMAIN and using"]
    #[doc = "protocol PROTOCOL, which are connected to each other, and put file"]
    #[doc = "descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,"]
    #[doc = "one will be chosen automatically.  Returns 0 on success, -1 for errors."]
    pub fn socketpair(
        __domain: cty::c_int,
        __type: cty::c_int,
        __protocol: cty::c_int,
        __fds: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Give the socket FD the local address ADDR (which is LEN bytes long)."]
    pub fn bind(__fd: cty::c_int, __addr: *const sockaddr, __len: socklen_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Put the local address of FD into *ADDR and its length in *LEN."]
    pub fn getsockname(
        __fd: cty::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Open a connection on socket FD to peer at ADDR (which LEN bytes long)."]
    #[doc = "For connectionless socket types, just set the default address to send to"]
    #[doc = "and the only address from which to accept transmissions."]
    #[doc = "Return 0 on success, -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn connect(__fd: cty::c_int, __addr: *const sockaddr, __len: socklen_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Put the address of the peer connected to socket FD into *ADDR"]
    #[doc = "(which is *LEN bytes long), and its actual length into *LEN."]
    pub fn getpeername(
        __fd: cty::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Send N bytes of BUF to socket FD.  Returns the number sent or -1."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn send(
        __fd: cty::c_int,
        __buf: *const cty::c_void,
        __n: size_t,
        __flags: cty::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Read N bytes into BUF from socket FD."]
    #[doc = "Returns the number read or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn recv(
        __fd: cty::c_int,
        __buf: *mut cty::c_void,
        __n: size_t,
        __flags: cty::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Send N bytes of BUF on socket FD to peer at address ADDR (which is"]
    #[doc = "ADDR_LEN bytes long).  Returns the number sent, or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn sendto(
        __fd: cty::c_int,
        __buf: *const cty::c_void,
        __n: size_t,
        __flags: cty::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Read N bytes into BUF through socket FD."]
    #[doc = "If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of"]
    #[doc = "the sender, and store the actual size of the address in *ADDR_LEN."]
    #[doc = "Returns the number of bytes read or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn recvfrom(
        __fd: cty::c_int,
        __buf: *mut cty::c_void,
        __n: size_t,
        __flags: cty::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Send a message described MESSAGE on socket FD."]
    #[doc = "Returns the number of bytes sent, or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn sendmsg(__fd: cty::c_int, __message: *const msghdr, __flags: cty::c_int) -> ssize_t;
}
extern "C" {
    #[doc = " Receive a message as described by MESSAGE from socket FD."]
    #[doc = "Returns the number of bytes read or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn recvmsg(__fd: cty::c_int, __message: *mut msghdr, __flags: cty::c_int) -> ssize_t;
}
extern "C" {
    #[doc = " Put the current value for socket FD's option OPTNAME at protocol level LEVEL"]
    #[doc = "into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's"]
    #[doc = "actual length.  Returns 0 on success, -1 for errors."]
    pub fn getsockopt(
        __fd: cty::c_int,
        __level: cty::c_int,
        __optname: cty::c_int,
        __optval: *mut cty::c_void,
        __optlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set socket FD's option OPTNAME at protocol level LEVEL"]
    #[doc = "to *OPTVAL (which is OPTLEN bytes long)."]
    #[doc = "Returns 0 on success, -1 for errors."]
    pub fn setsockopt(
        __fd: cty::c_int,
        __level: cty::c_int,
        __optname: cty::c_int,
        __optval: *const cty::c_void,
        __optlen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Prepare to accept connections on socket FD."]
    #[doc = "N connection requests will be queued before further requests are refused."]
    #[doc = "Returns 0 on success, -1 for errors."]
    pub fn listen(__fd: cty::c_int, __n: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Await a connection on socket FD."]
    #[doc = "When a connection arrives, open a new socket to communicate with it,"]
    #[doc = "set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting"]
    #[doc = "peer and *ADDR_LEN to the address's actual length, and return the"]
    #[doc = "new socket's descriptor, or -1 for errors."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn accept(
        __fd: cty::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Shut down all or part of the connection open on socket FD."]
    #[doc = "HOW determines what to shut down:"]
    #[doc = "SHUT_RD   = No more receptions;"]
    #[doc = "SHUT_WR   = No more transmissions;"]
    #[doc = "SHUT_RDWR = No more receptions or transmissions."]
    #[doc = "Returns 0 on success, -1 for errors."]
    pub fn shutdown(__fd: cty::c_int, __how: cty::c_int) -> cty::c_int;
}
#[doc = " Internet address."]
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[doc = " Dummy protocol for TCP."]
pub const IPPROTO_IP: cty::c_uint = 0;
#[doc = " Internet Control Message Protocol."]
pub const IPPROTO_ICMP: cty::c_uint = 1;
#[doc = " Internet Group Management Protocol."]
pub const IPPROTO_IGMP: cty::c_uint = 2;
#[doc = " IPIP tunnels (older KA9Q tunnels use 94)."]
pub const IPPROTO_IPIP: cty::c_uint = 4;
#[doc = " Transmission Control Protocol."]
pub const IPPROTO_TCP: cty::c_uint = 6;
#[doc = " Exterior Gateway Protocol."]
pub const IPPROTO_EGP: cty::c_uint = 8;
#[doc = " PUP protocol."]
pub const IPPROTO_PUP: cty::c_uint = 12;
#[doc = " User Datagram Protocol."]
pub const IPPROTO_UDP: cty::c_uint = 17;
#[doc = " XNS IDP protocol."]
pub const IPPROTO_IDP: cty::c_uint = 22;
#[doc = " SO Transport Protocol Class 4."]
pub const IPPROTO_TP: cty::c_uint = 29;
#[doc = " Datagram Congestion Control Protocol."]
pub const IPPROTO_DCCP: cty::c_uint = 33;
#[doc = " IPv6 header."]
pub const IPPROTO_IPV6: cty::c_uint = 41;
#[doc = " Reservation Protocol."]
pub const IPPROTO_RSVP: cty::c_uint = 46;
#[doc = " General Routing Encapsulation."]
pub const IPPROTO_GRE: cty::c_uint = 47;
#[doc = " encapsulating security payload."]
pub const IPPROTO_ESP: cty::c_uint = 50;
#[doc = " authentication header."]
pub const IPPROTO_AH: cty::c_uint = 51;
#[doc = " Multicast Transport Protocol."]
pub const IPPROTO_MTP: cty::c_uint = 92;
#[doc = " IP option pseudo header for BEET."]
pub const IPPROTO_BEETPH: cty::c_uint = 94;
#[doc = " Encapsulation Header."]
pub const IPPROTO_ENCAP: cty::c_uint = 98;
#[doc = " Protocol Independent Multicast."]
pub const IPPROTO_PIM: cty::c_uint = 103;
#[doc = " Compression Header Protocol."]
pub const IPPROTO_COMP: cty::c_uint = 108;
#[doc = " Stream Control Transmission Protocol."]
pub const IPPROTO_SCTP: cty::c_uint = 132;
#[doc = " UDP-Lite protocol."]
pub const IPPROTO_UDPLITE: cty::c_uint = 136;
#[doc = " MPLS in IP."]
pub const IPPROTO_MPLS: cty::c_uint = 137;
#[doc = " Raw IP packets."]
pub const IPPROTO_RAW: cty::c_uint = 255;
pub const IPPROTO_MAX: cty::c_uint = 256;
#[doc = " Standard well-defined IP protocols."]
pub type _bindgen_ty_6 = cty::c_uint;
#[doc = " IPv6 Hop-by-Hop options."]
pub const IPPROTO_HOPOPTS: cty::c_uint = 0;
#[doc = " IPv6 routing header."]
pub const IPPROTO_ROUTING: cty::c_uint = 43;
#[doc = " IPv6 fragmentation header."]
pub const IPPROTO_FRAGMENT: cty::c_uint = 44;
#[doc = " ICMPv6."]
pub const IPPROTO_ICMPV6: cty::c_uint = 58;
#[doc = " IPv6 no next header."]
pub const IPPROTO_NONE: cty::c_uint = 59;
#[doc = " IPv6 destination options."]
pub const IPPROTO_DSTOPTS: cty::c_uint = 60;
#[doc = " IPv6 mobility header."]
pub const IPPROTO_MH: cty::c_uint = 135;
pub type _bindgen_ty_7 = cty::c_uint;
#[doc = " Type to represent a port."]
pub type in_port_t = u16;
#[doc = " Echo service."]
pub const IPPORT_ECHO: cty::c_uint = 7;
#[doc = " Discard transmissions service."]
pub const IPPORT_DISCARD: cty::c_uint = 9;
#[doc = " System status service."]
pub const IPPORT_SYSTAT: cty::c_uint = 11;
#[doc = " Time of day service."]
pub const IPPORT_DAYTIME: cty::c_uint = 13;
#[doc = " Network status service."]
pub const IPPORT_NETSTAT: cty::c_uint = 15;
#[doc = " File Transfer Protocol."]
pub const IPPORT_FTP: cty::c_uint = 21;
#[doc = " Telnet protocol."]
pub const IPPORT_TELNET: cty::c_uint = 23;
#[doc = " Simple Mail Transfer Protocol."]
pub const IPPORT_SMTP: cty::c_uint = 25;
#[doc = " Timeserver service."]
pub const IPPORT_TIMESERVER: cty::c_uint = 37;
#[doc = " Domain Name Service."]
pub const IPPORT_NAMESERVER: cty::c_uint = 42;
#[doc = " Internet Whois service."]
pub const IPPORT_WHOIS: cty::c_uint = 43;
pub const IPPORT_MTP: cty::c_uint = 57;
#[doc = " Trivial File Transfer Protocol."]
pub const IPPORT_TFTP: cty::c_uint = 69;
pub const IPPORT_RJE: cty::c_uint = 77;
#[doc = " Finger service."]
pub const IPPORT_FINGER: cty::c_uint = 79;
pub const IPPORT_TTYLINK: cty::c_uint = 87;
#[doc = " SUPDUP protocol."]
pub const IPPORT_SUPDUP: cty::c_uint = 95;
#[doc = " execd service."]
pub const IPPORT_EXECSERVER: cty::c_uint = 512;
#[doc = " rlogind service."]
pub const IPPORT_LOGINSERVER: cty::c_uint = 513;
pub const IPPORT_CMDSERVER: cty::c_uint = 514;
pub const IPPORT_EFSSERVER: cty::c_uint = 520;
#[doc = " UDP ports."]
pub const IPPORT_BIFFUDP: cty::c_uint = 512;
#[doc = " UDP ports."]
pub const IPPORT_WHOSERVER: cty::c_uint = 513;
#[doc = " UDP ports."]
pub const IPPORT_ROUTESERVER: cty::c_uint = 520;
#[doc = " Ports less than this value are reserved for privileged processes."]
pub const IPPORT_RESERVED: cty::c_uint = 1024;
#[doc = " Ports greater this value are reserved for (non-privileged) servers."]
pub const IPPORT_USERRESERVED: cty::c_uint = 5000;
#[doc = " Standard well-known ports."]
pub type _bindgen_ty_8 = cty::c_uint;
#[doc = " IPv6 address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[doc = " Structure describing an Internet socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    #[doc = " Port number."]
    pub sin_port: in_port_t,
    #[doc = " Internet address."]
    pub sin_addr: in_addr,
    #[doc = " Pad to size of `struct sockaddr'."]
    pub sin_zero: [cty::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[doc = " Ditto, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    #[doc = " Transport layer port #"]
    pub sin6_port: in_port_t,
    #[doc = " IPv6 flow information"]
    pub sin6_flowinfo: u32,
    #[doc = " IPv6 address"]
    pub sin6_addr: in6_addr,
    #[doc = " IPv6 scope-id"]
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Likewise, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    #[doc = " IPv6 multicast address of group"]
    pub ipv6mr_multiaddr: in6_addr,
    #[doc = " local interface"]
    pub ipv6mr_interface: cty::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::core::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Functions to convert between host and network byte order."]
    #[doc = ""]
    #[doc = "Please note that these functions normally take `unsigned long int' or"]
    #[doc = "`unsigned short int' values as arguments and also return them.  But"]
    #[doc = "this was a short-sighted decision since on different systems the types"]
    #[doc = "may have different representations but the values are always the same."]
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    #[doc = " Get a human-readable string describing the running Notcurses version."]
    pub fn notcurses_version() -> *const cty::c_char;
}
extern "C" {
    #[doc = " Cannot be inline, as we want to get the versions of the actual Notcurses"]
    #[doc = " library we loaded, not what we compile against."]
    pub fn notcurses_version_components(
        major: *mut cty::c_int,
        minor: *mut cty::c_int,
        patch: *mut cty::c_int,
        tweak: *mut cty::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct notcurses {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncvisual {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncuplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncprogbar {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncfdplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncsubproc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmultiselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncfadectx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctablet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctabbed {
    _unused: [u8; 0],
}
#[doc = " let the ncvisual pick"]
pub const ncblitter_e_NCBLIT_DEFAULT: ncblitter_e = 0;
#[doc = " space, compatible with ASCII"]
pub const ncblitter_e_NCBLIT_1x1: ncblitter_e = 1;
#[doc = " halves + 1x1 (space)     "]
pub const ncblitter_e_NCBLIT_2x1: ncblitter_e = 2;
#[doc = " quadrants + 2x1           "]
pub const ncblitter_e_NCBLIT_2x2: ncblitter_e = 3;
#[doc = " sextants (*NOT* 2x2)     "]
pub const ncblitter_e_NCBLIT_3x2: ncblitter_e = 4;
#[doc = " 4 rows, 2 cols (braille) "]
pub const ncblitter_e_NCBLIT_BRAILLE: ncblitter_e = 5;
#[doc = " pixel graphics"]
pub const ncblitter_e_NCBLIT_PIXEL: ncblitter_e = 6;
#[doc = " four vertical levels     "]
pub const ncblitter_e_NCBLIT_4x1: ncblitter_e = 7;
#[doc = " eight vertical levels    "]
pub const ncblitter_e_NCBLIT_8x1: ncblitter_e = 8;
#[doc = " we never blit full blocks, but instead spaces (more efficient) with the"]
#[doc = " background set to the desired foreground."]
pub type ncblitter_e = cty::c_uint;
pub const ncalign_e_NCALIGN_UNALIGNED: ncalign_e = 0;
pub const ncalign_e_NCALIGN_LEFT: ncalign_e = 1;
pub const ncalign_e_NCALIGN_CENTER: ncalign_e = 2;
pub const ncalign_e_NCALIGN_RIGHT: ncalign_e = 3;
#[doc = " Alignment within a plane or terminal. Left/right-justified, or centered."]
pub type ncalign_e = cty::c_uint;
pub const ncscale_e_NCSCALE_NONE: ncscale_e = 0;
pub const ncscale_e_NCSCALE_SCALE: ncscale_e = 1;
pub const ncscale_e_NCSCALE_STRETCH: ncscale_e = 2;
pub const ncscale_e_NCSCALE_NONE_HIRES: ncscale_e = 3;
pub const ncscale_e_NCSCALE_SCALE_HIRES: ncscale_e = 4;
#[doc = " How to scale an ncvisual during rendering. NCSCALE_NONE will apply no"]
#[doc = " scaling. NCSCALE_SCALE scales a visual to the plane's size, maintaining"]
#[doc = " aspect ratio. NCSCALE_STRETCH stretches and scales the image in an"]
#[doc = " attempt to fill the entirety of the plane. NCSCALE_NONE_HIRES and"]
#[doc = " NCSCALE_SCALE_HIRES behave like their counterparts, but admit blitters"]
#[doc = " which don't preserve aspect ratio."]
pub type ncscale_e = cty::c_uint;
extern "C" {
    #[doc = " Returns the number of columns occupied by a multibyte (UTF-8) string, or"]
    #[doc = " -1 if a non-printable/illegal character is encountered."]
    pub fn ncstrwidth(mbs: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " input functions like notcurses_getc() return ucs32-encoded char32_t. convert"]
    #[doc = " a series of char32_t to utf8. result must be at least 4 bytes per input"]
    #[doc = " char32_t (6 bytes per char32_t will future-proof against Unicode expansion)."]
    #[doc = " the number of bytes used is returned, or -1 if passed illegal ucs32, or too"]
    #[doc = " small of a buffer."]
    pub fn notcurses_ucs32_to_utf8(
        ucs32: *const char32_t,
        ucs32count: cty::c_uint,
        resultbuf: *mut cty::c_uchar,
        buflen: size_t,
    ) -> cty::c_int;
}
#[doc = " An nccell corresponds to a single character cell on some plane, which can be"]
#[doc = " occupied by a single grapheme cluster (some root spacing glyph, along with"]
#[doc = " possible combining characters, which might span multiple columns). At any"]
#[doc = " cell, we can have a theoretically arbitrarily long UTF-8 string, a foreground"]
#[doc = " color, a background color, and an attribute set. Valid grapheme cluster"]
#[doc = " contents include:"]
#[doc = ""]
#[doc = "  * A NUL terminator,"]
#[doc = "  * A single control character, followed by a NUL terminator,"]
#[doc = "  * At most one spacing character, followed by zero or more nonspacing"]
#[doc = "    characters, followed by a NUL terminator."]
#[doc = ""]
#[doc = " Multi-column characters can only have a single style/color throughout."]
#[doc = " Existence is suffering, and thus wcwidth() is not reliable. It's just"]
#[doc = " quoting whether or not the EGC contains a \"Wide Asian\" double-width"]
#[doc = " character. This is set for some things, like most emoji, and not set for"]
#[doc = " other things, like cuneiform. True display width is a *function of the"]
#[doc = " font and terminal*. Among the longest Unicode codepoints is"]
#[doc = ""]
#[doc = "    U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM "]
#[doc = ""]
#[doc = " wcwidth() rather optimistically claims this most exalted glyph to occupy"]
#[doc = " a single column. BiDi text is too complicated for me to even get into here."]
#[doc = " Be assured there are no easy answers; ours is indeed a disturbing Universe."]
#[doc = ""]
#[doc = " Each nccell occupies 16 static bytes (128 bits). The surface is thus ~1.6MB"]
#[doc = " for a (pretty large) 500x200 terminal. At 80x43, it's less than 64KB."]
#[doc = " Dynamic requirements (the egcpool) can add up to 16MB to an ncplane, but"]
#[doc = " such large pools are unlikely in common use."]
#[doc = ""]
#[doc = " We implement some small alpha compositing. Foreground and background both"]
#[doc = " have two bits of inverted alpha. The actual grapheme written to a cell is"]
#[doc = " the topmost non-zero grapheme. If its alpha is 00, its foreground color is"]
#[doc = " used unchanged. If its alpha is 10, its foreground color is derived entirely"]
#[doc = " from cells underneath it. Otherwise, the result will be a composite."]
#[doc = " Likewise for the background. If the bottom of a coordinate's zbuffer is"]
#[doc = " reached with a cumulative alpha of zero, the default is used. In this way,"]
#[doc = " a terminal configured with transparent background can be supported through"]
#[doc = " multiple occluding ncplanes. A foreground alpha of 11 requests high-contrast"]
#[doc = " text (relative to the computed background). A background alpha of 11 is"]
#[doc = " currently forbidden."]
#[doc = ""]
#[doc = " Default color takes precedence over palette or RGB, and cannot be used with"]
#[doc = " transparency. Indexed palette takes precedence over RGB. It cannot"]
#[doc = " meaningfully set transparency, but it can be mixed into a cascading color."]
#[doc = " RGB is used if neither default terminal colors nor palette indexing are in"]
#[doc = " play, and fully supports all transparency options."]
#[doc = ""]
#[doc = " This structure is exposed only so that most functions can be inlined. Do not"]
#[doc = " directly modify or access the fields of this structure; use the API."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccell {
    #[doc = " 4B  4B little endian EGC"]
    pub gcluster: u32,
    #[doc = " 1B  5B (8 bits of zero)"]
    pub gcluster_backstop: u8,
    #[doc = " 1B  6B (8 bits of EGC column width)"]
    pub width: u8,
    #[doc = " 2B  8B (16 bits of NCSTYLE_* attributes)"]
    pub stylemask: u16,
    #[doc = " + 8B == 16B"]
    pub channels: u64,
}
#[test]
fn bindgen_test_layout_nccell() {
    assert_eq!(
        ::core::mem::size_of::<nccell>(),
        16usize,
        concat!("Size of: ", stringify!(nccell))
    );
    assert_eq!(
        ::core::mem::align_of::<nccell>(),
        8usize,
        concat!("Alignment of ", stringify!(nccell))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).gcluster as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(gcluster)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).gcluster_backstop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(gcluster_backstop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).width as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).stylemask as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(stylemask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(channels)
        )
    );
}
pub type cell = nccell;
extern "C" {
    #[doc = " Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'."]
    #[doc = " Returns the number of bytes copied out of 'gcluster', or -1 on failure. The"]
    #[doc = " styling of the cell is left untouched, but any resources are released."]
    pub fn cell_load(n: *mut ncplane, c: *mut nccell, gcluster: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Duplicate 'c' into 'targ'; both must be/will be bound to 'n'. Returns -1 on"]
    #[doc = " failure, and 0 on success."]
    pub fn cell_duplicate(n: *mut ncplane, targ: *mut nccell, c: *const nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Release resources held by the nccell 'c'."]
    pub fn cell_release(n: *mut ncplane, c: *mut nccell);
}
extern "C" {
    #[doc = " return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer"]
    #[doc = " can be invalidated by any further operation on the plane 'n', so...watch out!"]
    #[doc = " must not be called on a pixel graphic."]
    pub fn cell_extended_gcluster(n: *const ncplane, c: *const nccell) -> *const cty::c_char;
}
#[doc = " default. print nothing once fullscreen service begins"]
pub const ncloglevel_e_NCLOGLEVEL_SILENT: ncloglevel_e = 0;
#[doc = " print diagnostics immediately related to crashing"]
pub const ncloglevel_e_NCLOGLEVEL_PANIC: ncloglevel_e = 1;
#[doc = " we're hanging around, but we've had a horrible fault"]
pub const ncloglevel_e_NCLOGLEVEL_FATAL: ncloglevel_e = 2;
#[doc = " we can't keep doing this, but we can do other things"]
pub const ncloglevel_e_NCLOGLEVEL_ERROR: ncloglevel_e = 3;
#[doc = " you probably don't want what's happening to happen"]
pub const ncloglevel_e_NCLOGLEVEL_WARNING: ncloglevel_e = 4;
#[doc = " \"standard information\""]
pub const ncloglevel_e_NCLOGLEVEL_INFO: ncloglevel_e = 5;
#[doc = " \"detailed information\""]
pub const ncloglevel_e_NCLOGLEVEL_VERBOSE: ncloglevel_e = 6;
#[doc = " this is honestly a bit much"]
pub const ncloglevel_e_NCLOGLEVEL_DEBUG: ncloglevel_e = 7;
#[doc = " there's probably a better way to do what you want"]
pub const ncloglevel_e_NCLOGLEVEL_TRACE: ncloglevel_e = 8;
#[doc = " These log levels consciously map cleanly to those of libav; Notcurses itself"]
#[doc = " does not use this full granularity. The log level does not affect the opening"]
#[doc = " and closing banners, which can be disabled via the notcurses_option struct's"]
#[doc = " 'suppress_banner'. Note that if stderr is connected to the same terminal on"]
#[doc = " which we're rendering, any kind of logging will disrupt the output."]
pub type ncloglevel_e = cty::c_uint;
#[doc = " Configuration for notcurses_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct notcurses_options {
    #[doc = " The name of the terminfo database entry describing this terminal. If NULL,"]
    #[doc = " the environment variable TERM is used. Failure to open the terminal"]
    #[doc = " definition will result in failure to initialize notcurses."]
    pub termtype: *const cty::c_char,
    #[doc = " If non-NULL, notcurses_render() will write each rendered frame to this"]
    #[doc = " FILE* in addition to outfp. This is used primarily for debugging."]
    pub renderfp: *mut FILE,
    #[doc = " Progressively higher log levels result in more logging to stderr. By"]
    #[doc = " default, nothing is printed to stderr once fullscreen service begins."]
    pub loglevel: ncloglevel_e,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_t: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_r: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_b: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_l: cty::c_int,
    #[doc = " General flags; see NCOPTION_*. This is expressed as a bitfield so that"]
    #[doc = " future options can be added without reshaping the struct. Undefined bits"]
    #[doc = " must be set to 0."]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_notcurses_options() {
    assert_eq!(
        ::core::mem::size_of::<notcurses_options>(),
        48usize,
        concat!("Size of: ", stringify!(notcurses_options))
    );
    assert_eq!(
        ::core::mem::align_of::<notcurses_options>(),
        8usize,
        concat!("Alignment of ", stringify!(notcurses_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).termtype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(termtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).renderfp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(renderfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).loglevel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(loglevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_t as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_r as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_b as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_l as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_l)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for notcurses_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Lex a margin argument according to the standard Notcurses definition. There"]
    #[doc = " can be either a single number, which will define all margins equally, or"]
    #[doc = " there can be four numbers separated by commas."]
    pub fn notcurses_lex_margins(
        op: *const cty::c_char,
        opts: *mut notcurses_options,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Lex a blitter."]
    pub fn notcurses_lex_blitter(op: *const cty::c_char, blitter: *mut ncblitter_e) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the name of a blitter."]
    pub fn notcurses_str_blitter(blitter: ncblitter_e) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Lex a scaling mode (one of \"none\", \"stretch\", \"scale\", \"hires\", or \"scalehi\")."]
    pub fn notcurses_lex_scalemode(op: *const cty::c_char, scalemode: *mut ncscale_e)
        -> cty::c_int;
}
extern "C" {
    #[doc = " Get the name of a scaling mode."]
    pub fn notcurses_str_scalemode(scalemode: ncscale_e) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must"]
    #[doc = " be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in"]
    #[doc = " which case /dev/tty will be opened. Returns NULL on error, including any"]
    #[doc = " failure initializing terminfo."]
    pub fn notcurses_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " The same as notcurses_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn notcurses_core_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " Destroy a Notcurses context."]
    pub fn notcurses_stop(nc: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the topmost plane of the pile containing 'n'."]
    pub fn ncpile_top(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost plane of the pile containing 'n'."]
    pub fn ncpile_bottom(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Renders the pile of which 'n' is a part. Rendering this pile again will blow"]
    #[doc = " away the render. To actually write out the render, call ncpile_rasterize()."]
    pub fn ncpile_render(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Make the physical screen match the last rendered frame from the pile of"]
    #[doc = " which 'n' is a part. This is a blocking call. Don't call this before the"]
    #[doc = " pile has been rendered (doing so will likely result in a blank screen)."]
    pub fn ncpile_rasterize(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Renders and rasterizes the standard pile in one shot. Blocking call."]
    pub fn notcurses_render(nc: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Perform the rendering and rasterization portion of notcurses_render(), but"]
    #[doc = " do not write the resulting buffer out to the terminal. Using this function,"]
    #[doc = " the user can control the writeout process, and render a second frame while"]
    #[doc = " writing another. The returned buffer must be freed by the caller."]
    pub fn notcurses_render_to_buffer(
        nc: *mut notcurses,
        buf: *mut *mut cty::c_char,
        buflen: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write the last rendered frame, in its entirety, to 'fp'. If"]
    #[doc = " notcurses_render() has not yet been called, nothing will be written."]
    pub fn notcurses_render_to_file(nc: *mut notcurses, fp: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the topmost ncplane of the standard pile."]
    pub fn notcurses_top(n: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost ncplane of the standard pile."]
    pub fn notcurses_bottom(n: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    #[doc = " Destroy all ncplanes other than the stdplane."]
    pub fn notcurses_drop_planes(nc: *mut notcurses);
}
#[doc = " An input event. Cell coordinates are currently defined only for mouse events."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncinput {
    #[doc = " identifier. Unicode codepoint or synthesized NCKEY event"]
    pub id: char32_t,
    #[doc = " y cell coordinate of event, -1 for undefined"]
    pub y: cty::c_int,
    #[doc = " x cell coordinate of event, -1 for undefined"]
    pub x: cty::c_int,
    #[doc = " was alt held?"]
    pub alt: bool,
    #[doc = " was shift held?"]
    pub shift: bool,
    #[doc = " was ctrl held?"]
    pub ctrl: bool,
    #[doc = " input event number"]
    pub seqnum: u64,
}
#[test]
fn bindgen_test_layout_ncinput() {
    assert_eq!(
        ::core::mem::size_of::<ncinput>(),
        24usize,
        concat!("Size of: ", stringify!(ncinput))
    );
    assert_eq!(
        ::core::mem::align_of::<ncinput>(),
        8usize,
        concat!("Alignment of ", stringify!(ncinput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).alt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).shift as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).ctrl as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).seqnum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(seqnum)
        )
    );
}
extern "C" {
    #[doc = " See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts'"]
    #[doc = " of 0 for non-blocking operation, and otherwise a timespec to bound blocking."]
    #[doc = " Signals in sigmask (less several we handle internally) will be atomically"]
    #[doc = " masked and unmasked per ppoll(2). It should generally contain all signals."]
    #[doc = " Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may"]
    #[doc = " be NULL. Returns 0 on a timeout. If an event is processed, the return value"]
    #[doc = " is the 'id' field from that event. 'ni' may be NULL."]
    pub fn notcurses_getc(
        n: *mut notcurses,
        ts: *const timespec,
        sigmask: *mut sigset_t,
        ni: *mut ncinput,
    ) -> char32_t;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call notcurses_getc_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn notcurses_inputready_fd(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Enable the mouse in \"button-event tracking\" mode with focus detection and"]
    #[doc = " UTF8-style extended coordinates. On failure, -1 is returned. On success, 0"]
    #[doc = " is returned, and mouse events will be published to notcurses_getc()."]
    pub fn notcurses_mouse_enable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable mouse events. Any events in the input queue can still be delivered."]
    pub fn notcurses_mouse_disable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z). They are enabled by default."]
    pub fn notcurses_linesigs_disable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Restore signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z), if disabled."]
    pub fn notcurses_linesigs_enable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Refresh the physical screen to match what was last rendered (i.e., without"]
    #[doc = " reflecting any changes since the last call to notcurses_render()). This is"]
    #[doc = " primarily useful if the screen is externally corrupted, or if an"]
    #[doc = " NCKEY_RESIZE event has been read and you're not yet ready to render."]
    pub fn notcurses_refresh(
        n: *mut notcurses,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Extract the Notcurses context to which this plane is attached."]
    pub fn ncplane_notcurses(n: *mut ncplane) -> *mut notcurses;
}
extern "C" {
    pub fn ncplane_notcurses_const(n: *const ncplane) -> *const notcurses;
}
extern "C" {
    #[doc = " Return the dimensions of this ncplane."]
    pub fn ncplane_dim_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Get a reference to the standard plane (one matching our current idea of the"]
    #[doc = " terminal size) for this terminal. The standard plane always exists, and its"]
    #[doc = " origin is always at the uppermost, leftmost cell of the terminal."]
    pub fn notcurses_stdplane(nc: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    pub fn notcurses_stdplane_const(nc: *const notcurses) -> *const ncplane;
}
extern "C" {
    #[doc = " Retrieve pixel geometry for the display region ('pxy', 'pxx'), each cell"]
    #[doc = " ('celldimy', 'celldimx'), and the maximum displayable bitmap ('maxbmapy',"]
    #[doc = " 'maxbmapx'). Note that this will call notcurses_check_pixel_support(),"]
    #[doc = " possibly leading to an interrogation of the terminal. If bitmaps are not"]
    #[doc = " supported, 'maxbmapy' and 'maxbmapx' will be 0. Any of the geometry"]
    #[doc = " arguments may be NULL."]
    pub fn ncplane_pixelgeom(
        n: *mut ncplane,
        pxy: *mut cty::c_int,
        pxx: *mut cty::c_int,
        celldimy: *mut cty::c_int,
        celldimx: *mut cty::c_int,
        maxbmapy: *mut cty::c_int,
        maxbmapx: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " Retrieve the contents of the specified cell as last rendered. Returns the EGC"]
    #[doc = " or NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively."]
    pub fn notcurses_at_yx(
        nc: *mut notcurses,
        yoff: cty::c_int,
        xoff: cty::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplane_options {
    #[doc = " vertical placement relative to parent plane"]
    pub y: cty::c_int,
    #[doc = " horizontal placement relative to parent plane"]
    pub x: cty::c_int,
    #[doc = " rows, must be positive (unless NCPLANE_OPTION_MARGINALIZED)"]
    pub rows: cty::c_int,
    #[doc = " columns, must be positive (unless NCPLANE_OPTION_MARGINALIZED)"]
    pub cols: cty::c_int,
    #[doc = " user curry, may be NULL"]
    pub userptr: *mut cty::c_void,
    #[doc = " name (used only for debugging), may be NULL"]
    pub name: *const cty::c_char,
    #[doc = " callback when parent is resized"]
    pub resizecb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> cty::c_int>,
    #[doc = " closure over NCPLANE_OPTION_*"]
    pub flags: u64,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_b: cty::c_int,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_r: cty::c_int,
}
#[test]
fn bindgen_test_layout_ncplane_options() {
    assert_eq!(
        ::core::mem::size_of::<ncplane_options>(),
        56usize,
        concat!("Size of: ", stringify!(ncplane_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncplane_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncplane_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).rows as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).cols as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).userptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).resizecb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(resizecb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).margin_b as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(margin_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).margin_r as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(margin_r)
        )
    );
}
impl Default for ncplane_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to"]
    #[doc = " the origin of 'n') and the specified size. The number of 'rows' and 'cols'"]
    #[doc = " must both be positive. This plane is initially at the top of the z-buffer,"]
    #[doc = " as if ncplane_move_top() had been called on it. The void* 'userptr' can be"]
    #[doc = " retrieved (and reset) later. A 'name' can be set, used in debugging."]
    pub fn ncplane_create(n: *mut ncplane, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " Same as ncplane_create(), but creates a new pile. The returned plane will"]
    #[doc = " be the top, bottom, and root of this new pile."]
    pub fn ncpile_create(nc: *mut notcurses, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " This function will be removed in ABI3 in favor of ncplane_create()."]
    #[doc = " It persists in ABI2 only for backwards compatibility."]
    pub fn ncplane_new(
        n: *mut ncplane,
        rows: cty::c_int,
        cols: cty::c_int,
        y: cty::c_int,
        x: cty::c_int,
        opaque: *mut cty::c_void,
        name: *const cty::c_char,
    ) -> *mut ncplane;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb', this will resize the plane to the visual"]
    #[doc = " region's size. It is used for the standard plane."]
    pub fn ncplane_resize_maximize(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb' with planes created with"]
    #[doc = " NCPLANE_OPTION_MARGINALIZED. This will resize the plane 'n' against its"]
    #[doc = " parent, attempting to enforce the supplied margins."]
    pub fn ncplane_resize_marginalized(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb'. This will realign the plane 'n' against"]
    #[doc = " its parent, using the alignment specified at ncplane_create()-time."]
    pub fn ncplane_resize_realign(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL)."]
    #[doc = " The standard plane's resizecb may not be changed."]
    pub fn ncplane_set_resizecb(
        n: *mut ncplane,
        resizecb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> cty::c_int>,
    );
}
extern "C" {
    #[doc = " Returns the ncplane's current resize callback."]
    pub fn ncplane_resizecb(
        n: *const ncplane,
    ) -> ::core::option::Option<unsafe extern "C" fn(n: *mut ncplane) -> cty::c_int>;
}
extern "C" {
    #[doc = " Plane 'n' will be unbound from its parent plane, and will be made a bound"]
    #[doc = " child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If"]
    #[doc = " 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n'"]
    #[doc = " is already the root of a pile, in which case this is a no-op. Returns 'n'."]
    #[doc = " The standard plane cannot be reparented. Any planes bound to 'n' are"]
    #[doc = " reparented to the previous parent of 'n'."]
    pub fn ncplane_reparent(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " The same as ncplane_reparent(), except any planes bound to 'n' come along"]
    #[doc = " with it to its new destination. Their z-order is maintained. If 'newparent'"]
    #[doc = " is an ancestor of 'n', NULL is returned, and no changes are made."]
    pub fn ncplane_reparent_family(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Duplicate an existing ncplane. The new plane will have the same geometry,"]
    #[doc = " will duplicate all content, and will start with the same rendering state."]
    #[doc = " The new plane will be immediately above the old one on the z axis, and will"]
    #[doc = " be bound to the same parent. Bound planes are *not* duplicated; the new"]
    #[doc = " plane is bound to the parent of 'n', but has no bound planes."]
    pub fn ncplane_dup(n: *const ncplane, opaque: *mut cty::c_void) -> *mut ncplane;
}
extern "C" {
    #[doc = " provided a coordinate relative to the origin of 'src', map it to the same"]
    #[doc = " absolute coordinate relative to the origin of 'dst'. either or both of 'y'"]
    #[doc = " and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."]
    pub fn ncplane_translate(
        src: *const ncplane,
        dst: *const ncplane,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " Fed absolute 'y'/'x' coordinates, determine whether that coordinate is"]
    #[doc = " within the ncplane 'n'. If not, return false. If so, return true. Either"]
    #[doc = " way, translate the absolute coordinates relative to 'n'. If the point is not"]
    #[doc = " within 'n', these coordinates will not be within the dimensions of the plane."]
    pub fn ncplane_translate_abs(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int)
        -> bool;
}
extern "C" {
    #[doc = " All planes are created with scrolling disabled. Scrolling can be dynamically"]
    #[doc = " controlled with ncplane_set_scrolling(). Returns true if scrolling was"]
    #[doc = " previously enabled, or false if it was disabled."]
    pub fn ncplane_set_scrolling(n: *mut ncplane, scrollp: bool) -> bool;
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes"]
    #[doc = " (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only"]
    #[doc = " indicated as supported if the terminal can support it together with color."]
    #[doc = " For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn notcurses_supported_styles(nc: *const notcurses) -> cty::c_uint;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn notcurses_palette_size(nc: *const notcurses) -> cty::c_uint;
}
extern "C" {
    #[doc = " Can we directly specify RGB values per cell, or only use palettes?"]
    pub fn notcurses_cantruecolor(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we fade? Fading requires either the \"rgb\" or \"ccc\" terminfo capability."]
    pub fn notcurses_canfade(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we set the \"hardware\" palette? Requires the \"ccc\" terminfo capability."]
    pub fn notcurses_canchangecolor(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn notcurses_canopen_images(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load videos? This requires being built against FFmpeg."]
    pub fn notcurses_canopen_videos(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn notcurses_canutf8(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode 13 sextants?"]
    pub fn notcurses_cansextant(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode Braille?"]
    pub fn notcurses_canbraille(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " This function must successfully return before NCBLIT_PIXEL is available."]
    #[doc = " Returns -1 on error, 0 for no support, or 1 if pixel output is supported."]
    #[doc = " Must not be called concurrently with either input or rasterization."]
    pub fn notcurses_check_pixel_support(nc: *mut notcurses) -> cty::c_int;
}
#[doc = " whenever a new field is added here, ensure we add the proper rule to"]
#[doc = " notcurses_stats_reset(), so that values are preserved in the stash stats."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncstats {
    #[doc = " successful ncpile_render() runs"]
    pub renders: u64,
    #[doc = " successful ncpile_rasterize() runs"]
    pub writeouts: u64,
    #[doc = " aborted renders, should be 0"]
    pub failed_renders: u64,
    #[doc = " aborted writes"]
    pub failed_writeouts: u64,
    #[doc = " bytes emitted to ttyfp"]
    pub render_bytes: u64,
    #[doc = " max bytes emitted for a frame"]
    pub render_max_bytes: i64,
    #[doc = " min bytes emitted for a frame"]
    pub render_min_bytes: i64,
    #[doc = " nanoseconds spent rendering"]
    pub render_ns: u64,
    #[doc = " max ns spent in render for a frame"]
    pub render_max_ns: i64,
    #[doc = " min ns spent in render for a frame"]
    pub render_min_ns: i64,
    #[doc = " nanoseconds spent writing frames to terminal"]
    pub writeout_ns: u64,
    #[doc = " max ns spent writing out a frame"]
    pub writeout_max_ns: i64,
    #[doc = " min ns spent writing out a frame"]
    pub writeout_min_ns: i64,
    #[doc = " cells we elided entirely thanks to damage maps"]
    pub cellelisions: u64,
    #[doc = " total number of cells emitted to terminal"]
    pub cellemissions: u64,
    #[doc = " RGB fg elision count"]
    pub fgelisions: u64,
    #[doc = " RGB fg emissions"]
    pub fgemissions: u64,
    #[doc = " RGB bg elision count"]
    pub bgelisions: u64,
    #[doc = " RGB bg emissions"]
    pub bgemissions: u64,
    #[doc = " default color was emitted"]
    pub defaultelisions: u64,
    #[doc = " default color was elided"]
    pub defaultemissions: u64,
    #[doc = " refresh requests (non-optimized redraw)"]
    pub refreshes: u64,
    #[doc = " total bytes devoted to all active framebuffers"]
    pub fbbytes: u64,
    #[doc = " number of planes currently in existence"]
    pub planes: cty::c_uint,
    #[doc = " nanoseconds spent rasterizing"]
    pub raster_ns: u64,
    #[doc = " max ns spent in raster for a frame"]
    pub raster_max_ns: i64,
    #[doc = " min ns spent in raster for a frame"]
    pub raster_min_ns: i64,
}
#[test]
fn bindgen_test_layout_ncstats() {
    assert_eq!(
        ::core::mem::size_of::<ncstats>(),
        216usize,
        concat!("Size of: ", stringify!(ncstats))
    );
    assert_eq!(
        ::core::mem::align_of::<ncstats>(),
        8usize,
        concat!("Alignment of ", stringify!(ncstats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).renders as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(renders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeouts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).failed_renders as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(failed_renders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).failed_writeouts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(failed_writeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_max_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_max_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_min_bytes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_min_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_ns as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_max_ns as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_min_ns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_min_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_ns as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_max_ns as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_min_ns as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_min_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).cellelisions as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(cellelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).cellemissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(cellemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fgelisions as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fgelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fgemissions as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fgemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).bgelisions as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(bgelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).bgemissions as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(bgemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).defaultelisions as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(defaultelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).defaultemissions as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(defaultemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).refreshes as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(refreshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fbbytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fbbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).planes as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_ns as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_max_ns as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_min_ns as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_min_ns)
        )
    );
}
extern "C" {
    #[doc = " Allocate an ncstats object. Use this rather than allocating your own, since"]
    #[doc = " future versions of Notcurses might enlarge this structure."]
    pub fn notcurses_stats_alloc(nc: *const notcurses) -> *mut ncstats;
}
extern "C" {
    #[doc = " Acquire an atomic snapshot of the Notcurses object's stats."]
    pub fn notcurses_stats(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Reset all cumulative stats (immediate ones, such as fbbytes, are not reset),"]
    #[doc = " first copying them into |*stats| (if |stats| is not NULL)."]
    pub fn notcurses_stats_reset(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Resize the specified ncplane. The four parameters 'keepy', 'keepx',"]
    #[doc = " 'keepleny', and 'keeplenx' define a subset of the ncplane to keep,"]
    #[doc = " unchanged. This may be a section of size 0, though none of these four"]
    #[doc = " parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane."]
    #[doc = " They must specify a coordinate within the ncplane's totality. 'yoff' and"]
    #[doc = " 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner"]
    #[doc = " of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the"]
    #[doc = " ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny',"]
    #[doc = " and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to"]
    #[doc = " attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx'"]
    #[doc = " is non-zero, both must be non-zero."]
    #[doc = ""]
    #[doc = " Essentially, the kept material does not move. It serves to anchor the"]
    #[doc = " resized plane. If there is no kept material, the plane can move freely."]
    pub fn ncplane_resize(
        n: *mut ncplane,
        keepy: cty::c_int,
        keepx: cty::c_int,
        keepleny: cty::c_int,
        keeplenx: cty::c_int,
        yoff: cty::c_int,
        xoff: cty::c_int,
        ylen: cty::c_int,
        xlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Destroy the specified ncplane. None of its contents will be visible after"]
    #[doc = " the next call to notcurses_render(). It is an error to attempt to destroy"]
    #[doc = " the standard plane."]
    pub fn ncplane_destroy(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell to 'c'. The base cell is used for purposes of"]
    #[doc = " rendering anywhere that the ncplane's gcluster is 0. Note that the base cell"]
    #[doc = " is not affected by ncplane_erase(). 'c' must not be a secondary cell from a"]
    #[doc = " multicolumn EGC."]
    pub fn ncplane_set_base_cell(n: *mut ncplane, c: *const nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell. It will be used for purposes of rendering"]
    #[doc = " anywhere that the ncplane's gcluster is 0. Note that the base cell is not"]
    #[doc = " affected by ncplane_erase(). 'egc' must be an extended grapheme cluster."]
    pub fn ncplane_set_base(
        n: *mut ncplane,
        egc: *const cty::c_char,
        stylemask: u32,
        channels: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Extract the ncplane's base nccell into 'c'. The reference is invalidated if"]
    #[doc = " 'ncp' is destroyed."]
    pub fn ncplane_base(n: *mut ncplane, c: *mut nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Move this plane relative to the standard plane, or the plane to which it is"]
    #[doc = " bound (if it is bound to a plane). It is an error to attempt to move the"]
    #[doc = " standard plane."]
    pub fn ncplane_move_yx(n: *mut ncplane, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its bound plane, or pile (if 'n' is"]
    #[doc = " a root plane). To get absolute coordinates, use ncplane_abs_yx()."]
    pub fn ncplane_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    pub fn ncplane_y(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_x(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its pile. Either or both of 'x' and"]
    #[doc = " 'y' may be NULL."]
    pub fn ncplane_abs_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    pub fn ncplane_abs_y(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_abs_x(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the plane to which the plane 'n' is bound, if any."]
    pub fn ncplane_parent(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_parent_const(n: *const ncplane) -> *const ncplane;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom."]
    pub fn ncplane_move_top(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_move_bottom(n: *mut ncplane);
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'above' must not be the same plane."]
    pub fn ncplane_move_above(n: *mut ncplane, above: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'below' must not be the same plane."]
    pub fn ncplane_move_below(n: *mut ncplane, below: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the plane below this one, or NULL if this is at the bottom."]
    pub fn ncplane_below(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_above(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Rotate the plane /2 radians clockwise or counterclockwise. This cannot"]
    #[doc = " be performed on arbitrary planes, because glyphs cannot be arbitrarily"]
    #[doc = " rotated. The glyphs which can be rotated are limited: line-drawing"]
    #[doc = " characters, spaces, half blocks, and full blocks. The plane must have"]
    #[doc = " an even number of columns. Use the ncvisual rotation for a more"]
    #[doc = " flexible approach."]
    pub fn ncplane_rotate_cw(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_rotate_ccw(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor. The EGC is"]
    #[doc = " returned, or NULL on error. This EGC must be free()d by the caller. The"]
    #[doc = " stylemask and channels are written to 'stylemask' and 'channels', respectively."]
    pub fn ncplane_at_cursor(
        n: *mut ncplane,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor into 'c'. This"]
    #[doc = " cell is invalidated if the associated plane is destroyed. Returns the number"]
    #[doc = " of bytes in the EGC, or -1 on error."]
    pub fn ncplane_at_cursor_cell(n: *mut ncplane, c: *mut nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell. The EGC is returned, or"]
    #[doc = " NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively."]
    pub fn ncplane_at_yx(
        n: *const ncplane,
        y: cty::c_int,
        x: cty::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell into 'c'. This cell is"]
    #[doc = " invalidated if the associated plane is destroyed. Returns the number of"]
    #[doc = " bytes in the EGC, or -1 on error."]
    pub fn ncplane_at_yx_cell(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Create a flat string from the EGCs of the selected region of the ncplane"]
    #[doc = " 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as -1 to go through the boundary of the plane."]
    pub fn ncplane_contents(
        n: *const ncplane,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Manipulate the opaque user pointer associated with this plane."]
    #[doc = " ncplane_set_userptr() returns the previous userptr after replacing"]
    #[doc = " it with 'opaque'. the others simply return the userptr."]
    pub fn ncplane_set_userptr(n: *mut ncplane, opaque: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn ncplane_userptr(n: *mut ncplane) -> *mut cty::c_void;
}
extern "C" {
    pub fn ncplane_center_abs(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Move the cursor to the specified position (the cursor needn't be visible)."]
    #[doc = " Returns -1 on error, including negative parameters, or ones exceeding the"]
    #[doc = " plane's dimensions."]
    pub fn ncplane_cursor_move_yx(n: *mut ncplane, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Move the cursor to 0, 0. Can't fail."]
    pub fn ncplane_home(n: *mut ncplane);
}
extern "C" {
    #[doc = " Get the current position of the cursor within n. y and/or x may be NULL."]
    pub fn ncplane_cursor_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Get the current channels or attribute word for ncplane 'n'."]
    pub fn ncplane_channels(n: *const ncplane) -> u64;
}
extern "C" {
    #[doc = " Return the current styling for this ncplane."]
    pub fn ncplane_styles(n: *const ncplane) -> u16;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided cell 'c',"]
    #[doc = " and advance the cursor by the width of the cell (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " 'c' must already be associated with 'n'. On failure, -1 is returned."]
    pub fn ncplane_putc_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *const nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putchar_stained(n: *mut ncplane, c: cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided EGC, and"]
    #[doc = " advance the cursor by the width of the cluster (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " On failure, -1 is returned. The number of bytes converted from gclust is"]
    #[doc = " written to 'sbytes' if non-NULL."]
    pub fn ncplane_putegc_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        gclust: *const cty::c_char,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putegc_stained(
        n: *mut ncplane,
        gclust: *const cty::c_char,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putwegc_stained(
        n: *mut ncplane,
        gclust: *const wchar_t,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a series of EGCs to the current location, using the current style."]
    #[doc = " They will be interpreted as a series of columns (according to the definition"]
    #[doc = " of ncplane_putc()). Advances the cursor by some positive number of columns"]
    #[doc = " (though not beyond the end of the plane); this number is returned on success."]
    #[doc = " On error, a non-positive number is returned, indicating the number of columns"]
    #[doc = " which were written before the error."]
    pub fn ncplane_putstr_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        gclusters: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putstr_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        s: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace a string's worth of glyphs at the current cursor location, but"]
    #[doc = " retain the styling. The current styling of the plane will not be changed."]
    pub fn ncplane_putstr_stained(n: *mut ncplane, s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a series of EGCs to the current location, using the current style."]
    #[doc = " They will be interpreted as a series of columns (according to the definition"]
    #[doc = " of ncplane_putc()). Advances the cursor by some positive number of columns"]
    #[doc = " (though not beyond the end of the plane); this number is returned on success."]
    #[doc = " On error, a non-positive number is returned, indicating the number of columns"]
    #[doc = " which were written before the error. No more than 's' bytes will be written."]
    pub fn ncplane_putnstr_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        s: size_t,
        gclusters: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putnstr_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        s: size_t,
        gclustarr: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putwstr_stained(n: *mut ncplane, gclustarr: *const wchar_t) -> cty::c_int;
}
extern "C" {
    #[doc = " The ncplane equivalents of printf(3) and vprintf(3)."]
    pub fn ncplane_vprintf_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_stained(
        n: *mut ncplane,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write the specified text to the plane, breaking lines sensibly, beginning at"]
    #[doc = " the specified line. Returns the number of columns written. When breaking a"]
    #[doc = " line, the line will be cleared to the end of the plane (the last line will"]
    #[doc = " *not* be so cleared). The number of bytes written from the input is written"]
    #[doc = " to '*bytes' if it is not NULL. Cleared columns are included in the return"]
    #[doc = " value, but *not* included in the number of bytes written. Leaves the cursor"]
    #[doc = " at the end of output. A partial write will be accomplished as far as it can;"]
    #[doc = " determine whether the write completed by inspecting '*bytes'. Can output to"]
    #[doc = " multiple rows even in the absence of scrolling, but not more rows than are"]
    #[doc = " available. With scrolling enabled, arbitrary amounts of data can be emitted."]
    #[doc = " All provided whitespace is preserved -- ncplane_puttext() followed by an"]
    #[doc = " appropriate ncplane_contents() will read back the original output."]
    #[doc = ""]
    #[doc = " If 'y' is -1, the first row of output is taken relative to the current"]
    #[doc = " cursor: it will be left-, right-, or center-aligned in whatever remains"]
    #[doc = " of the row. On subsequent rows -- or if 'y' is not -1 -- the entire row can"]
    #[doc = " be used, and alignment works normally."]
    #[doc = ""]
    #[doc = " A newline at any point will move the cursor to the next row."]
    pub fn ncplane_puttext(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        text: *const cty::c_char,
        bytes: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw horizontal or vertical lines using the specified cell, starting at the"]
    #[doc = " current cursor position. The cursor will end at the cell following the last"]
    #[doc = " cell output (even, perhaps counter-intuitively, when drawing vertical"]
    #[doc = " lines), just as if ncplane_putc() was called at that spot. Return the"]
    #[doc = " number of cells drawn on success. On error, return the negative number of"]
    #[doc = " cells drawn."]
    pub fn ncplane_hline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: cty::c_int,
        c1: u64,
        c2: u64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: cty::c_int,
        c1: u64,
        c2: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, and its"]
    #[doc = " lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the"]
    #[doc = " upper-left, ur, ll, and lr corners, then the horizontal and vertical lines."]
    #[doc = " 'ctlword' is defined in the least significant byte, where bits [7, 4] are a"]
    #[doc = " gradient mask, and [3, 0] are a border mask:"]
    #[doc = "  * 7, 3: top"]
    #[doc = "  * 6, 2: right"]
    #[doc = "  * 5, 1: bottom"]
    #[doc = "  * 4, 0: left"]
    #[doc = " If the gradient bit is not set, the styling from the hl/vl cells is used for"]
    #[doc = " the horizontal and vertical lines, respectively. If the gradient bit is set,"]
    #[doc = " the color is linearly interpolated between the two relevant corner cells."]
    #[doc = ""]
    #[doc = " By default, vertexes are drawn whether their connecting edges are drawn or"]
    #[doc = " not. The value of the bits corresponding to NCBOXCORNER_MASK control this,"]
    #[doc = " and are interpreted as the number of connecting edges necessary to draw a"]
    #[doc = " given corner. At 0 (the default), corners are always drawn. At 3, corners"]
    #[doc = " are never drawn (since at most 2 edges can touch a box's corner)."]
    pub fn ncplane_box(
        n: *mut ncplane,
        ul: *const nccell,
        ur: *const nccell,
        ll: *const nccell,
        lr: *const nccell,
        hline: *const nccell,
        vline: *const nccell,
        ystop: cty::c_int,
        xstop: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Starting at the specified coordinate, if its glyph is different from that of"]
    #[doc = " 'c', 'c' is copied into it, and the original glyph is considered the fill"]
    #[doc = " target. We do the same to all cardinally-connected cells having this same"]
    #[doc = " fill target. Returns the number of cells polyfilled. An invalid initial y, x"]
    #[doc = " is an error. Returns the number of cells filled, or -1 on error."]
    pub fn ncplane_polyfill_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *const nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a gradient with its upper-left corner at the current cursor position,"]
    #[doc = " stopping at 'ystop'x'xstop'. The glyph composed of 'egc' and 'stylemask' is"]
    #[doc = " used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'"]
    #[doc = " are composed into foreground and background gradients. To do a vertical"]
    #[doc = " gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a"]
    #[doc = " horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To"]
    #[doc = " color everything the same, all four channels should be equivalent. The"]
    #[doc = " resulting alpha values are equal to incoming alpha values. Returns the"]
    #[doc = " number of cells filled on success, or -1 on failure."]
    #[doc = ""]
    #[doc = " Palette-indexed color is not supported."]
    #[doc = ""]
    #[doc = " Preconditions for gradient operations (error otherwise):"]
    #[doc = ""]
    #[doc = "  all: only RGB colors, unless all four channels match as default"]
    #[doc = "  all: all alpha values must be the same"]
    #[doc = "  1x1: all four colors must be the same"]
    #[doc = "  1xN: both top and both bottom colors must be the same (vertical gradient)"]
    #[doc = "  Nx1: both left and both right colors must be the same (horizontal gradient)"]
    pub fn ncplane_gradient(
        n: *mut ncplane,
        egc: *const cty::c_char,
        stylemask: u32,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ystop: cty::c_int,
        xstop: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Do a high-resolution gradient using upper blocks and synced backgrounds."]
    #[doc = " This doubles the number of vertical gradations, but restricts you to"]
    #[doc = " half blocks (appearing to be full blocks). Returns the number of cells"]
    #[doc = " filled on success, or -1 on error."]
    pub fn ncplane_highgradient(
        n: *mut ncplane,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
        ystop: cty::c_int,
        xstop: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncplane_gradent_sized() meets ncplane_highgradient()."]
    pub fn ncplane_highgradient_sized(
        n: *mut ncplane,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
        ylen: cty::c_int,
        xlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the given style throughout the specified region, keeping content and"]
    #[doc = " channels unchanged. Returns the number of cells set, or -1 on failure."]
    pub fn ncplane_format(
        n: *mut ncplane,
        ystop: cty::c_int,
        xstop: cty::c_int,
        stylemask: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the given channels throughout the specified region, keeping content and"]
    #[doc = " attributes unchanged. Returns the number of cells set, or -1 on failure."]
    pub fn ncplane_stain(
        n: *mut ncplane,
        ystop: cty::c_int,
        xstop: cty::c_int,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " If 'src' does not intersect with 'dst', 'dst' will not be changed, but it is"]
    #[doc = " not an error. If 'dst' is NULL, the operation will target the standard plane."]
    pub fn ncplane_mergedown_simple(src: *const ncplane, dst: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously"]
    #[doc = " defined as \"write to 'dst' the frame that would be rendered were the entire"]
    #[doc = " stack made up only of the specified subregion of 'src' and, below it, the"]
    #[doc = " subregion of 'dst' having the specified origin. Merging is independent of"]
    #[doc = " the position of 'src' viz 'dst' on the z-axis. It is an error to define a"]
    #[doc = " subregion of zero area, or that is not entirely contained within 'src'. It"]
    #[doc = " is an error to define a target origin such that the projected subregion is"]
    #[doc = " not entirely contained within 'dst'.  Behavior is undefined if 'src' and"]
    #[doc = " 'dst' are equivalent. 'dst' is modified, but 'src' remains unchanged."]
    pub fn ncplane_mergedown(
        src: *const ncplane,
        dst: *mut ncplane,
        begsrcy: cty::c_int,
        begsrcx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
        dsty: cty::c_int,
        dstx: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Erase every cell in the ncplane (each cell is initialized to the null glyph"]
    #[doc = " and the default channels/styles). All cells associated with this ncplane are"]
    #[doc = " invalidated, and must not be used after the call, *excluding* the base cell."]
    #[doc = " The cursor is homed. The plane's active attributes are unaffected."]
    pub fn ncplane_erase(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_set_channels(n: *mut ncplane, channels: u64);
}
extern "C" {
    #[doc = " Set the specified style bits for the ncplane 'n', whether they're actively"]
    #[doc = " supported or not."]
    pub fn ncplane_set_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Add the specified styles to the ncplane's existing spec."]
    pub fn ncplane_on_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Remove the specified styles from the ncplane's existing spec."]
    pub fn ncplane_off_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Deprecated forms of above."]
    pub fn ncplane_styles_set(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    pub fn ncplane_styles_on(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    pub fn ncplane_styles_off(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Set an entire 32-bit channel of the plane"]
    pub fn ncplane_set_fchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    pub fn ncplane_set_bchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the current fore/background color using RGB specifications. If the"]
    #[doc = " terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\","]
    #[doc = " indicated by the \"RGB\" terminfo capability), the provided values will be"]
    #[doc = " interpreted in some lossy fashion. None of r, g, or b may exceed 255."]
    #[doc = " \"HP-like\" terminals require setting foreground and background at the same"]
    #[doc = " time using \"color pairs\"; Notcurses will manage color pairs transparently."]
    pub fn ncplane_set_fg_rgb8(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb8(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Same, but clipped to [0..255]."]
    pub fn ncplane_set_bg_rgb8_clipped(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    );
}
extern "C" {
    pub fn ncplane_set_fg_rgb8_clipped(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    );
}
extern "C" {
    #[doc = " Same, but with rgb assembled into a channel (i.e. lower 24 bits)."]
    pub fn ncplane_set_fg_rgb(n: *mut ncplane, channel: u32) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb(n: *mut ncplane, channel: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Use the default color for the foreground/background."]
    pub fn ncplane_set_fg_default(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_set_bg_default(n: *mut ncplane);
}
extern "C" {
    #[doc = " Set the ncplane's foreground palette index, set the foreground palette index"]
    #[doc = " bit, set it foreground-opaque, and clear the foreground default color bit."]
    pub fn ncplane_set_fg_palindex(n: *mut ncplane, idx: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_palindex(n: *mut ncplane, idx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the alpha parameters for ncplane 'n'."]
    pub fn ncplane_set_fg_alpha(n: *mut ncplane, alpha: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_alpha(n: *mut ncplane, alpha: cty::c_int) -> cty::c_int;
}
#[doc = " Called for each fade iteration on 'ncp'. If anything but 0 is returned,"]
#[doc = " the fading operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type fadecb = ::core::option::Option<
    unsafe extern "C" fn(
        nc: *mut notcurses,
        n: *mut ncplane,
        arg1: *const timespec,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Fade the ncplane out over the provided time, calling 'fader' at each"]
    #[doc = " iteration. Requires a terminal which supports truecolor, or at least palette"]
    #[doc = " modification (if the terminal uses a palette, our ability to fade planes is"]
    #[doc = " limited, and affected by the complexity of the rest of the screen)."]
    pub fn ncplane_fadeout(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade the ncplane in over the specified time. Load the ncplane with the"]
    #[doc = " target cells without rendering, then call this function. When it's done, the"]
    #[doc = " ncplane will have reached the target levels, starting from zeroes."]
    pub fn ncplane_fadein(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be"]
    #[doc = " paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."]
    pub fn ncfadectx_setup(n: *mut ncplane) -> *mut ncfadectx;
}
extern "C" {
    #[doc = " Return the number of iterations through which 'nctx' will fade."]
    pub fn ncfadectx_iterations(nctx: *const ncfadectx) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade out through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadeout_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: cty::c_int,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade in through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadein_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: cty::c_int,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Pulse the plane in and out until the callback returns non-zero, relying on"]
    #[doc = " the callback 'fader' to initiate rendering. 'ts' defines the half-period"]
    #[doc = " (i.e. the transition from black to full brightness, or back again). Proper"]
    #[doc = " use involves preparing (but not rendering) an ncplane, then calling"]
    #[doc = " ncplane_pulse(), which will fade in from black to the specified colors."]
    pub fn ncplane_pulse(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Release the resources associated with 'nctx'."]
    pub fn ncfadectx_free(nctx: *mut ncfadectx);
}
extern "C" {
    pub fn cells_rounded_box(
        n: *mut ncplane,
        styles: u32,
        channels: u64,
        ul: *mut nccell,
        ur: *mut nccell,
        ll: *mut nccell,
        lr: *mut nccell,
        hl: *mut nccell,
        vl: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cells_double_box(
        n: *mut ncplane,
        styles: u32,
        channels: u64,
        ul: *mut nccell,
        ur: *mut nccell,
        ll: *mut nccell,
        lr: *mut nccell,
        hl: *mut nccell,
        vl: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Open a visual at 'file', extract a codec and parameters, decode the first"]
    #[doc = " image to memory."]
    pub fn ncvisual_from_file(file: *const cty::c_char) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Prepare an ncvisual, and its underlying plane, based off RGBA content in"]
    #[doc = " memory at 'rgba'. 'rgba' is laid out as 'rows' lines, each of which is"]
    #[doc = " 'rowstride' bytes in length. Each line has 'cols' 32-bit 8bpc RGBA pixels"]
    #[doc = " followed by possible padding (there will be 'rowstride' - 'cols' * 4 bytes"]
    #[doc = " of padding). The total size of 'rgba' is thus (rows * rowstride) bytes, of"]
    #[doc = " which (rows * cols * 4) bytes are actual non-padding data."]
    pub fn ncvisual_from_rgba(
        rgba: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'bgra' is arranged as BGRA."]
    pub fn ncvisual_from_bgra(
        bgra: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces,"]
    #[doc = " half blocks, and full blocks. The latter will be checked, and any other"]
    #[doc = " glyph will result in a NULL being returned. This function exists so that"]
    #[doc = " planes can be subjected to ncvisual transformations. If possible, it's"]
    #[doc = " better to create the ncvisual from memory using ncvisual_from_rgba()."]
    pub fn ncvisual_from_plane(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
    ) -> *mut ncvisual;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvisual_options {
    #[doc = " if no ncplane is provided, one will be created using the exact size"]
    #[doc = " necessary to render the source with perfect fidelity (this might be"]
    #[doc = " smaller or larger than the rendering area)."]
    pub n: *mut ncplane,
    #[doc = " the scaling is ignored if no ncplane is provided (it ought be NCSCALE_NONE"]
    #[doc = " in this case). otherwise, the source is stretched/scaled relative to the"]
    #[doc = " provided ncplane."]
    pub scaling: ncscale_e,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub y: cty::c_int,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub x: cty::c_int,
    #[doc = " origin of rendered section"]
    pub begy: cty::c_int,
    #[doc = " origin of rendered section"]
    pub begx: cty::c_int,
    #[doc = " size of rendered section"]
    pub leny: cty::c_int,
    #[doc = " size of rendered section"]
    pub lenx: cty::c_int,
    #[doc = " glyph set to use (maps input to output cells)"]
    pub blitter: ncblitter_e,
    #[doc = " bitmask over NCVISUAL_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncvisual_options() {
    assert_eq!(
        ::core::mem::size_of::<ncvisual_options>(),
        48usize,
        concat!("Size of: ", stringify!(ncvisual_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncvisual_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncvisual_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).scaling as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).begy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(begy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).begx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(begx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).leny as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(leny)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).lenx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(lenx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).blitter as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(blitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncvisual_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create an RGBA flat array from the selected region of the ncplane 'nc'."]
    #[doc = " Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as -1 to go through the boundary of the plane."]
    #[doc = " Only glyphs from the specified ncblitset may be present. If 'pxdimy' and/or"]
    #[doc = " 'pxdimx' are non-NULL, they will be filled in with the pixel geometry."]
    pub fn ncplane_as_rgba(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
        pxdimy: *mut cty::c_int,
        pxdimx: *mut cty::c_int,
    ) -> *mut u32;
}
extern "C" {
    #[doc = " Get the size and ratio of ncvisual pixels to output cells along the y"]
    #[doc = " ('toy') and x ('tox') axes. A ncvisual of '*y'X'*x' pixels will require"]
    #[doc = " ('*y' * '*toy')X('*x' * '*tox') cells for full output. Returns non-zero"]
    #[doc = " for an invalid 'vopts->blitter'. Scaling is taken into consideration."]
    #[doc = " The blitter that will be used is returned in '*blitter'."]
    pub fn ncvisual_blitter_geom(
        nc: *const notcurses,
        n: *const ncvisual,
        vopts: *const ncvisual_options,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
        toy: *mut cty::c_int,
        tox: *mut cty::c_int,
        blitter: *mut ncblitter_e,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Destroy an ncvisual. Rendered elements will not be disrupted, but the visual"]
    #[doc = " can be neither decoded nor rendered any further."]
    pub fn ncvisual_destroy(ncv: *mut ncvisual);
}
extern "C" {
    #[doc = " extract the next frame from an ncvisual. returns 1 on end of file, 0 on"]
    #[doc = " success, and -1 on failure."]
    pub fn ncvisual_decode(nc: *mut ncvisual) -> cty::c_int;
}
extern "C" {
    #[doc = " decode the next frame ala ncvisual_decode(), but if we have reached the end,"]
    #[doc = " rewind to the first frame of the ncvisual. a subsequent 'ncvisual_render()'"]
    #[doc = " will render the first frame, as if the ncvisual had been closed and reopened."]
    #[doc = " the return values remain the same as those of ncvisual_decode()."]
    pub fn ncvisual_decode_loop(nc: *mut ncvisual) -> cty::c_int;
}
extern "C" {
    #[doc = " Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are"]
    #[doc = " supported at the moment, but this will change FIXME."]
    pub fn ncvisual_rotate(n: *mut ncvisual, rads: f64) -> cty::c_int;
}
extern "C" {
    #[doc = " Resize the visual so that it is 'rows' X 'columns'. This is a lossy"]
    #[doc = " transformation, unless the size is unchanged."]
    pub fn ncvisual_resize(n: *mut ncvisual, rows: cty::c_int, cols: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Polyfill at the specified location within the ncvisual 'n', using 'rgba'."]
    pub fn ncvisual_polyfill_yx(
        n: *mut ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        rgba: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the specified pixel from the specified ncvisual."]
    pub fn ncvisual_at_yx(
        n: *const ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        pixel: *mut u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the specified pixel in the specified ncvisual."]
    pub fn ncvisual_set_yx(
        n: *const ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        pixel: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Render the decoded frame to the specified ncplane. If one is not provided,"]
    #[doc = " one will be created, having the exact size necessary to display the visual."]
    #[doc = " A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and"]
    #[doc = " 'leny'. Negative values for 'begy' or 'begx' are an error. It is an error to"]
    #[doc = " specify any region beyond the boundaries of the frame. Returns the"]
    #[doc = " (possibly newly-created) plane to which we drew."]
    pub fn ncvisual_render(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        vopts: *const ncvisual_options,
    ) -> *mut ncplane;
}
extern "C" {
    #[doc = " If a subtitle ought be displayed at this time, return a heap-allocated copy"]
    #[doc = " of the UTF8 text."]
    pub fn ncvisual_subtitle(ncv: *const ncvisual) -> *mut cty::c_char;
}
#[doc = " Called for each frame rendered from 'ncv'. If anything but 0 is returned,"]
#[doc = " the streaming operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type ncstreamcb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ncvisual,
        arg2: *mut ncvisual_options,
        arg3: *const timespec,
        arg4: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Shut up and display my frames! Provide as an argument to ncvisual_stream()."]
    #[doc = " If you'd like subtitles to be decoded, provide an ncplane as the curry. If the"]
    #[doc = " curry is NULL, subtitles will not be displayed."]
    pub fn ncvisual_simple_streamer(
        ncv: *mut ncvisual,
        vopts: *mut ncvisual_options,
        tspec: *const timespec,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Stream the entirety of the media, according to its own timing. Blocking,"]
    #[doc = " obviously. streamer may be NULL; it is otherwise called for each frame, and"]
    #[doc = " its return value handled as outlined for streamcb. If streamer() returns"]
    #[doc = " non-zero, the stream is aborted, and that value is returned. By convention,"]
    #[doc = " return a positive number to indicate intentional abort from within"]
    #[doc = " streamer(). 'timescale' allows the frame duration time to be scaled. For a"]
    #[doc = " visual naturally running at 30FPS, a 'timescale' of 0.1 will result in"]
    #[doc = " 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to"]
    #[doc = " supply 'timescale' less than or equal to 0."]
    pub fn ncvisual_stream(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        timescale: f32,
        streamer: ncstreamcb,
        vopts: *const ncvisual_options,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n',"]
    #[doc = " which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative"]
    #[doc = " to the specified plane. Each source row ought occupy 'linesize' bytes (this"]
    #[doc = " might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A"]
    #[doc = " subregion of the input can be specified with the 'begy'x'begx' and"]
    #[doc = " 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or"]
    #[doc = " -1 on error."]
    pub fn ncblit_rgba(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Same as ncblit_rgba(), but for BGRx."]
    pub fn ncblit_bgrx(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreel_options {
    #[doc = " bitfield; 1s will not be drawn (see bordermaskbits)"]
    pub bordermask: cty::c_uint,
    #[doc = " attributes used for ncreel border"]
    pub borderchan: u64,
    #[doc = " bitfield; same as bordermask but for tablet borders"]
    pub tabletmask: cty::c_uint,
    #[doc = " tablet border styling channel"]
    pub tabletchan: u64,
    #[doc = " focused tablet border styling channel"]
    pub focusedchan: u64,
    #[doc = " bitfield over NCREEL_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncreel_options() {
    assert_eq!(
        ::core::mem::size_of::<ncreel_options>(),
        48usize,
        concat!("Size of: ", stringify!(ncreel_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncreel_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncreel_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).bordermask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(bordermask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).borderchan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(borderchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).tabletmask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(tabletmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).tabletchan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(tabletchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).focusedchan as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(focusedchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Take over the ncplane 'nc' and use it to draw a reel according to 'popts'."]
    #[doc = " The plane will be destroyed by ncreel_destroy(); this transfers ownership."]
    pub fn ncreel_create(n: *mut ncplane, popts: *const ncreel_options) -> *mut ncreel;
}
extern "C" {
    #[doc = " Returns the ncplane on which this ncreel lives."]
    pub fn ncreel_plane(nr: *mut ncreel) -> *mut ncplane;
}
#[doc = " Tablet draw callback, provided a tablet (from which the ncplane and userptr"]
#[doc = " may be extracted), and a bool indicating whether output ought be drawn from"]
#[doc = " the top (true) or bottom (false). Returns non-negative count of output lines,"]
#[doc = " which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."]
pub type tabletcb =
    ::core::option::Option<unsafe extern "C" fn(t: *mut nctablet, drawfromtop: bool) -> cty::c_int>;
extern "C" {
    #[doc = " Add a new nctablet to the provided ncreel 'nr', having the callback object"]
    #[doc = " 'opaque'. Neither, either, or both of 'after' and 'before' may be specified."]
    #[doc = " If neither is specified, the new tablet can be added anywhere on the reel."]
    #[doc = " If one or the other is specified, the tablet will be added before or after"]
    #[doc = " the specified tablet. If both are specified, the tablet will be added to the"]
    #[doc = " resulting location, assuming it is valid (after->next == before->prev); if"]
    #[doc = " it is not valid, or there is any other error, NULL will be returned."]
    pub fn ncreel_add(
        nr: *mut ncreel,
        after: *mut nctablet,
        before: *mut nctablet,
        cb: tabletcb,
        opaque: *mut cty::c_void,
    ) -> *mut nctablet;
}
extern "C" {
    #[doc = " Return the number of nctablets in the ncreel 'nr'."]
    pub fn ncreel_tabletcount(nr: *const ncreel) -> cty::c_int;
}
extern "C" {
    #[doc = " Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the"]
    #[doc = " tablet cannot be found."]
    pub fn ncreel_del(nr: *mut ncreel, t: *mut nctablet) -> cty::c_int;
}
extern "C" {
    #[doc = " Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and"]
    #[doc = " tablets will be lain out, using the focused tablet as a fulcrum. Tablet"]
    #[doc = " drawing callbacks will be invoked for each visible tablet."]
    pub fn ncreel_redraw(nr: *mut ncreel) -> cty::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the reel, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on a tablet (focuses tablet)"]
    #[doc = "  * a mouse scrollwheel event (rolls reel)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn ncreel_offer_input(nr: *mut ncreel, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused tablet, if any tablets are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn ncreel_focused(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the next tablet, if one exists"]
    pub fn ncreel_next(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the previous tablet, if one exists"]
    pub fn ncreel_prev(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Destroy an ncreel allocated with ncreel_create()."]
    pub fn ncreel_destroy(nr: *mut ncreel);
}
extern "C" {
    #[doc = " Returns a pointer to a user pointer associated with this nctablet."]
    pub fn nctablet_userptr(t: *mut nctablet) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Access the ncplane associated with nctablet 't', if one exists."]
    pub fn nctablet_plane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " Deprecated form of nctablet_plane()."]
    pub fn nctablet_ncplane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " Takes an arbitrarily large number, and prints it into a fixed-size buffer by"]
    #[doc = " adding the necessary SI suffix. Usually, pass a |[IB]PREFIXSTRLEN+1|-sized"]
    #[doc = " buffer to generate up to |[IB]PREFIXCOLUMNS| columns' worth of EGCs. The"]
    #[doc = " characteristic can occupy up through |mult-1| characters (3 for 1000, 4 for"]
    #[doc = " 1024). The mantissa can occupy either zero or two characters."]
    #[doc = ""]
    #[doc = " Floating-point is never used, because an IEEE758 double can only losslessly"]
    #[doc = " represent integers through 2^53-1."]
    #[doc = ""]
    #[doc = " 2^64-1 is 18446744073709551615, 18.45E(xa). KMGTPEZY thus suffice to handle"]
    #[doc = " an 89-bit uintmax_t. Beyond Z(etta) and Y(otta) lie lands unspecified by SI."]
    #[doc = " 2^-63 is 0.000000000000000000108, 1.08a(tto)."]
    #[doc = " val: value to print"]
    #[doc = " decimal: scaling. '1' if none has taken place."]
    #[doc = " buf: buffer in which string will be generated"]
    #[doc = " omitdec: inhibit printing of all-0 decimal portions"]
    #[doc = " mult: base of suffix system (almost always 1000 or 1024)"]
    #[doc = " uprefix: character to print following suffix ('i' for kibibytes basically)."]
    #[doc = "   only printed if suffix is actually printed (input >= mult)."]
    #[doc = ""]
    #[doc = " You are encouraged to consult notcurses_metric(3)."]
    pub fn ncmetric(
        val: uintmax_t,
        decimal: uintmax_t,
        buf: *mut cty::c_char,
        omitdec: cty::c_int,
        mult: uintmax_t,
        uprefix: cty::c_int,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Enable or disable the terminal's cursor, if supported, placing it at"]
    #[doc = " 'y', 'x'. Immediate effect (no need for a call to notcurses_render())."]
    #[doc = " It is an error if 'y', 'x' lies outside the standard plane."]
    pub fn notcurses_cursor_enable(nc: *mut notcurses, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn notcurses_cursor_disable(nc: *mut notcurses) -> cty::c_int;
}
#[doc = " Palette API. Some terminals only support 256 colors, but allow the full"]
#[doc = " palette to be specified with arbitrary RGB colors. In all cases, it's more"]
#[doc = " performant to use indexed colors, since it's much less data to write to the"]
#[doc = " terminal. If you can limit yourself to 256 colors, that's probably best."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct palette256 {
    #[doc = " RGB values as regular ol' channels"]
    pub chans: [u32; 256usize],
}
#[test]
fn bindgen_test_layout_palette256() {
    assert_eq!(
        ::core::mem::size_of::<palette256>(),
        1024usize,
        concat!("Size of: ", stringify!(palette256))
    );
    assert_eq!(
        ::core::mem::align_of::<palette256>(),
        4usize,
        concat!("Alignment of ", stringify!(palette256))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<palette256>())).chans as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(palette256),
            "::",
            stringify!(chans)
        )
    );
}
impl Default for palette256 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create a new palette store. It will be initialized with notcurses' best"]
    #[doc = " knowledge of the currently configured palette. The palette upon startup"]
    #[doc = " cannot be reliably detected, sadly."]
    pub fn palette256_new(nc: *mut notcurses) -> *mut palette256;
}
extern "C" {
    #[doc = " Attempt to configure the terminal with the provided palette 'p'. Does not"]
    #[doc = " transfer ownership of 'p'; palette256_free() can (ought) still be called."]
    pub fn palette256_use(nc: *mut notcurses, p: *const palette256) -> cty::c_int;
}
extern "C" {
    #[doc = " Free the palette store 'p'."]
    pub fn palette256_free(p: *mut palette256);
}
extern "C" {
    #[doc = " Convert the plane's content to greyscale."]
    pub fn ncplane_greyscale(n: *mut ncplane);
}
#[doc = " selection widget -- an ncplane with a title header and a body section. the"]
#[doc = " body section supports infinite scrolling up and down."]
#[doc = ""]
#[doc = " At all times, exactly one item is selected."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_item {
    pub option: *mut cty::c_char,
    pub desc: *mut cty::c_char,
    #[doc = " filled in by library"]
    pub opcolumns: size_t,
    #[doc = " filled in by library"]
    pub desccolumns: size_t,
}
#[test]
fn bindgen_test_layout_ncselector_item() {
    assert_eq!(
        ::core::mem::size_of::<ncselector_item>(),
        32usize,
        concat!("Size of: ", stringify!(ncselector_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncselector_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncselector_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).opcolumns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(opcolumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).desccolumns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(desccolumns)
        )
    );
}
impl Default for ncselector_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *mut cty::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *mut cty::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *mut cty::c_char,
    #[doc = " initial items and descriptions"]
    pub items: *mut ncselector_item,
    #[doc = " default item (selected at start), must be < itemcount unless itemcount is"]
    #[doc = " 0, in which case 'defidx' must also be 0"]
    pub defidx: cty::c_uint,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: cty::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCSELECTOR_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncselector_options() {
    assert_eq!(
        ::core::mem::size_of::<ncselector_options>(),
        88usize,
        concat!("Size of: ", stringify!(ncselector_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncselector_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncselector_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).secondary as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).footer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).items as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).defidx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(defidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).maxdisplay as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(maxdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).opchannels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(opchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).descchannels as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(descchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).titlechannels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(titlechannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).footchannels as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(footchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).boxchannels as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(boxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncselector_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ncselector_create(n: *mut ncplane, opts: *const ncselector_options) -> *mut ncselector;
}
extern "C" {
    #[doc = " Dynamically add or delete items. It is usually sufficient to supply a static"]
    #[doc = " list of items via ncselector_options->items."]
    pub fn ncselector_additem(n: *mut ncselector, item: *const ncselector_item) -> cty::c_int;
}
extern "C" {
    pub fn ncselector_delitem(n: *mut ncselector, item: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Return reference to the selected option, or NULL if there are no items."]
    pub fn ncselector_selected(n: *const ncselector) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return a reference to the ncselector's underlying ncplane."]
    pub fn ncselector_plane(n: *mut ncselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Move up or down in the list. A reference to the newly-selected item is"]
    #[doc = " returned, or NULL if there are no items in the list."]
    pub fn ncselector_previtem(n: *mut ncselector) -> *const cty::c_char;
}
extern "C" {
    pub fn ncselector_nextitem(n: *mut ncselector) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Offer the input to the ncselector. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the selector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncselector_offer_input(n: *mut ncselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncselector. If 'item' is not NULL, the last selected option will"]
    #[doc = " be strdup()ed and assigned to '*item' (and must be free()d by the caller)."]
    pub fn ncselector_destroy(n: *mut ncselector, item: *mut *mut cty::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmselector_item {
    pub option: *mut cty::c_char,
    pub desc: *mut cty::c_char,
    pub selected: bool,
}
#[test]
fn bindgen_test_layout_ncmselector_item() {
    assert_eq!(
        ::core::mem::size_of::<ncmselector_item>(),
        24usize,
        concat!("Size of: ", stringify!(ncmselector_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmselector_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmselector_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).selected as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(selected)
        )
    );
}
impl Default for ncmselector_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " multiselection widget -- a selector supporting multiple selections."]
#[doc = ""]
#[doc = " Unlike the selector widget, zero to all of the items can be selected, but"]
#[doc = " also the widget does not support adding or removing items at runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmultiselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *mut cty::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *mut cty::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *mut cty::c_char,
    #[doc = " initial items, descriptions, and statuses"]
    pub items: *mut ncmselector_item,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: cty::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCMULTISELECTOR_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncmultiselector_options() {
    assert_eq!(
        ::core::mem::size_of::<ncmultiselector_options>(),
        88usize,
        concat!("Size of: ", stringify!(ncmultiselector_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmultiselector_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmultiselector_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).secondary as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).footer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).items as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).maxdisplay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(maxdisplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).opchannels as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(opchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).descchannels as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(descchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).titlechannels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(titlechannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).footchannels as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(footchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).boxchannels as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(boxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncmultiselector_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ncmultiselector_create(
        n: *mut ncplane,
        opts: *const ncmultiselector_options,
    ) -> *mut ncmultiselector;
}
extern "C" {
    #[doc = " Return selected vector. An array of bools must be provided, along with its"]
    #[doc = " length. If that length doesn't match the itemcount, it is an error."]
    pub fn ncmultiselector_selected(
        n: *mut ncmultiselector,
        selected: *mut bool,
        count: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Return a reference to the ncmultiselector's underlying ncplane."]
    pub fn ncmultiselector_plane(n: *mut ncmultiselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmultiselector. If it's relevant, this function"]
    #[doc = " returns true, and the input ought not be processed further. If it's"]
    #[doc = " irrelevant to the multiselector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncmultiselector_offer_input(n: *mut ncmultiselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncmultiselector."]
    pub fn ncmultiselector_destroy(n: *mut ncmultiselector);
}
#[doc = " each item has a curry, and zero or more subitems."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_item {
    pub curry: *mut cty::c_void,
    pub subs: *mut nctree_item,
    pub subcount: cty::c_uint,
}
#[test]
fn bindgen_test_layout_nctree_item() {
    assert_eq!(
        ::core::mem::size_of::<nctree_item>(),
        24usize,
        concat!("Size of: ", stringify!(nctree_item))
    );
    assert_eq!(
        ::core::mem::align_of::<nctree_item>(),
        8usize,
        concat!("Alignment of ", stringify!(nctree_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).subs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).subcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(subcount)
        )
    );
}
impl Default for nctree_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_options {
    #[doc = " top-level nctree_item array"]
    pub items: *const nctree_item,
    #[doc = " size of |items|"]
    pub count: cty::c_uint,
    #[doc = " item callback function"]
    pub nctreecb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ncplane,
            arg2: *mut cty::c_void,
            arg3: cty::c_int,
        ) -> cty::c_int,
    >,
    #[doc = " columns to indent per level of hierarchy"]
    pub indentcols: cty::c_int,
    #[doc = " bitfield of NCTREE_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_nctree_options() {
    assert_eq!(
        ::core::mem::size_of::<nctree_options>(),
        40usize,
        concat!("Size of: ", stringify!(nctree_options))
    );
    assert_eq!(
        ::core::mem::align_of::<nctree_options>(),
        8usize,
        concat!("Alignment of ", stringify!(nctree_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).nctreecb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(nctreecb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).indentcols as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(indentcols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for nctree_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctree {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " |opts| may *not* be NULL, since it is necessary to define a callback"]
    #[doc = " function."]
    pub fn nctree_create(n: *mut ncplane, opts: *const nctree_options) -> *mut nctree;
}
extern "C" {
    #[doc = " Returns the ncplane on which this nctree lives."]
    pub fn nctree_plane(n: *mut nctree) -> *mut ncplane;
}
extern "C" {
    #[doc = " Redraw the nctree 'n' in its entirety. The tree will be cleared, and items"]
    #[doc = " will be lain out, using the focused item as a fulcrum. Item-drawing"]
    #[doc = " callbacks will be invoked for each visible item."]
    pub fn nctree_redraw(n: *mut nctree) -> cty::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the nctree 'n'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the tree, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item (focuses item)"]
    #[doc = "  * a mouse scrollwheel event (srolls tree)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn nctree_offer_input(n: *mut nctree, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused item, if any items are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn nctree_focused(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change focus to the next item."]
    pub fn nctree_next(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change focus to the previous item."]
    pub fn nctree_prev(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Go to the item specified by the array |spec|, terminated by UINT_MAX. If"]
    #[doc = " the spec is invalid, NULL is returned, and the depth of the first invalid"]
    #[doc = " spec is written to *|failspec|. Otherwise, the true depth is written to"]
    #[doc = " *|failspec|, and the curry is returned (|failspec| is necessary because the"]
    #[doc = " curry could itself be NULL)."]
    pub fn nctree_goto(
        n: *mut nctree,
        spec: *const cty::c_uint,
        failspec: *mut cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Destroy the nctree."]
    pub fn nctree_destroy(n: *mut nctree);
}
#[doc = " Menus. Horizontal menu bars are supported, on the top and/or bottom rows."]
#[doc = " If the menu bar is longer than the screen, it will be only partially"]
#[doc = " visible. Menus may be either visible or invisible by default. In the event of"]
#[doc = " a screen resize, menus will be automatically moved/resized. Elements can be"]
#[doc = " dynamically enabled or disabled at all levels (menu, section, and item),"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_item {
    #[doc = " utf-8 menu item, NULL for horizontal separator"]
    pub desc: *mut cty::c_char,
    #[doc = " shortcut, all should be distinct"]
    pub shortcut: ncinput,
}
#[test]
fn bindgen_test_layout_ncmenu_item() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_item>(),
        32usize,
        concat!("Size of: ", stringify!(ncmenu_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_item>())).desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_item>())).shortcut as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_item),
            "::",
            stringify!(shortcut)
        )
    );
}
impl Default for ncmenu_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_section {
    #[doc = " utf-8 c string"]
    pub name: *mut cty::c_char,
    pub itemcount: cty::c_int,
    pub items: *mut ncmenu_item,
    #[doc = " shortcut, will be underlined if present in name"]
    pub shortcut: ncinput,
}
#[test]
fn bindgen_test_layout_ncmenu_section() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_section>(),
        48usize,
        concat!("Size of: ", stringify!(ncmenu_section))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_section>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_section))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).itemcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(itemcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).shortcut as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(shortcut)
        )
    );
}
impl Default for ncmenu_section {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_options {
    #[doc = " array of 'sectioncount' menu_sections"]
    pub sections: *mut ncmenu_section,
    #[doc = " must be positive"]
    pub sectioncount: cty::c_int,
    #[doc = " styling for header"]
    pub headerchannels: u64,
    #[doc = " styling for sections"]
    pub sectionchannels: u64,
    #[doc = " flag word of NCMENU_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncmenu_options() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_options>(),
        40usize,
        concat!("Size of: ", stringify!(ncmenu_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sections as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sectioncount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sectioncount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).headerchannels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(headerchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sectionchannels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sectionchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncmenu_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmenu {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a menu with the specified options. Menus are currently bound to an"]
    #[doc = " overall Notcurses object (as opposed to a particular plane), and are"]
    #[doc = " implemented as ncplanes kept atop other ncplanes."]
    pub fn ncmenu_create(n: *mut ncplane, opts: *const ncmenu_options) -> *mut ncmenu;
}
extern "C" {
    #[doc = " Unroll the specified menu section, making the menu visible if it was"]
    #[doc = " invisible, and rolling up any menu section that is already unrolled."]
    pub fn ncmenu_unroll(n: *mut ncmenu, sectionidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Roll up any unrolled menu section, and hide the menu if using hiding."]
    pub fn ncmenu_rollup(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Unroll the previous/next section (relative to current unrolled). If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextsection(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    pub fn ncmenu_prevsection(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Move to the previous/next item within the currently unrolled section. If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextitem(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    pub fn ncmenu_previtem(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable or enable a menu item. Returns 0 if the item was found."]
    pub fn ncmenu_item_set_status(
        n: *mut ncmenu,
        section: *const cty::c_char,
        item: *const cty::c_char,
        enabled: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the selected item description, or NULL if no section is unrolled. If"]
    #[doc = " 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled"]
    #[doc = " in with that shortcut--this can allow faster matching."]
    pub fn ncmenu_selected(n: *const ncmenu, ni: *mut ncinput) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return the item description corresponding to the mouse click 'click'. The"]
    #[doc = " item must be on an actively unrolled section, and the click must be in the"]
    #[doc = " area of a valid item. If 'ni' is not NULL, and the selected item has a"]
    #[doc = " shortcut, 'ni' will be filled in with the shortcut."]
    pub fn ncmenu_mouse_selected(
        n: *const ncmenu,
        click: *const ncinput,
        ni: *mut ncinput,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return the ncplane backing this ncmenu."]
    pub fn ncmenu_plane(n: *mut ncmenu) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmenu. If it's relevant, this function returns true,"]
    #[doc = " and the input ought not be processed further. If it's irrelevant to the"]
    #[doc = " menu, false is returned. Relevant inputs include:"]
    #[doc = "  * mouse movement over a hidden menu"]
    #[doc = "  * a mouse click on a menu section (the section is unrolled)"]
    #[doc = "  * a mouse click outside of an unrolled menu (the menu is rolled up)"]
    #[doc = "  * left or right on an unrolled menu (navigates among sections)"]
    #[doc = "  * up or down on an unrolled menu (navigates among items)"]
    #[doc = "  * escape on an unrolled menu (the menu is rolled up)"]
    pub fn ncmenu_offer_input(n: *mut ncmenu, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy a menu created with ncmenu_create()."]
    pub fn ncmenu_destroy(n: *mut ncmenu) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncprogbar_options {
    #[doc = " upper-left channel. in the context of a progress bar,"]
    pub ulchannel: u32,
    #[doc = " \"up\" is the direction we are progressing towards, and"]
    pub urchannel: u32,
    #[doc = " \"bottom\" is the direction of origin. for monochromatic"]
    pub blchannel: u32,
    #[doc = " bar, all four channels ought be the same."]
    pub brchannel: u32,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncprogbar_options() {
    assert_eq!(
        ::core::mem::size_of::<ncprogbar_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncprogbar_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncprogbar_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncprogbar_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).ulchannel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(ulchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).urchannel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(urchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).blchannel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(blchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).brchannel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(brchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Takes ownership of the ncplane 'n', which will be destroyed by"]
    #[doc = " ncprogbar_destroy(). The progress bar is initially at 0%."]
    pub fn ncprogbar_create(n: *mut ncplane, opts: *const ncprogbar_options) -> *mut ncprogbar;
}
extern "C" {
    #[doc = " Return a reference to the ncprogbar's underlying ncplane."]
    pub fn ncprogbar_plane(n: *mut ncprogbar) -> *mut ncplane;
}
extern "C" {
    #[doc = " Set the progress bar's completion, a double 0 <= 'p' <= 1."]
    pub fn ncprogbar_set_progress(n: *mut ncprogbar, p: f64) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the progress bar's completion, a double on [0, 1]."]
    pub fn ncprogbar_progress(n: *const ncprogbar) -> f64;
}
extern "C" {
    #[doc = " Destroy the progress bar and its underlying ncplane."]
    pub fn ncprogbar_destroy(n: *mut ncprogbar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctabbed_options {
    #[doc = " channel for the selected tab header"]
    pub selchan: u64,
    #[doc = " channel for unselected tab headers"]
    pub hdrchan: u64,
    #[doc = " channel for the tab separator"]
    pub sepchan: u64,
    #[doc = " separator string (copied by nctabbed_create())"]
    pub separator: *mut cty::c_char,
    #[doc = " bitmask of NCTABBED_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_nctabbed_options() {
    assert_eq!(
        ::core::mem::size_of::<nctabbed_options>(),
        40usize,
        concat!("Size of: ", stringify!(nctabbed_options))
    );
    assert_eq!(
        ::core::mem::align_of::<nctabbed_options>(),
        8usize,
        concat!("Alignment of ", stringify!(nctabbed_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).selchan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(selchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).hdrchan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(hdrchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).sepchan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(sepchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).separator as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for nctabbed_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Tab content drawing callback. Takes the tab it was associated to, the ncplane"]
#[doc = " on which tab content is to be drawn, and the user pointer of the tab."]
#[doc = " It is called during nctabbed_redraw()."]
pub type tabcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctab, ncp: *mut ncplane, curry: *mut cty::c_void),
>;
extern "C" {
    #[doc = " Creates a new nctabbed widget, associated with the given ncplane 'n', and with"]
    #[doc = " additional options given in 'opts'. When 'opts' is NULL, it acts as if it were"]
    #[doc = " called with an all-zero opts. The widget takes ownership of 'n', and destroys"]
    #[doc = " it when the widget is destroyed. Returns the newly created widget. Returns"]
    #[doc = " NULL on failure, also destroying 'n'."]
    pub fn nctabbed_create(n: *mut ncplane, opts: *const nctabbed_options) -> *mut nctabbed;
}
extern "C" {
    #[doc = " Destroy an nctabbed widget. All memory belonging to 'nt' is deallocated,"]
    #[doc = " including all tabs and their names. The plane associated with 'nt' is also"]
    #[doc = " destroyed. Calling this with NULL does nothing."]
    pub fn nctabbed_destroy(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Redraw the widget. This calls the tab callback of the currently selected tab"]
    #[doc = " to draw tab contents, and draws tab headers. The tab content plane is not"]
    #[doc = " modified by this function, apart from resizing the plane is necessary."]
    pub fn nctabbed_redraw(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Make sure the tab header of the currently selected tab is at least partially"]
    #[doc = " visible. (by rotating tabs until at least one column is displayed)"]
    #[doc = " Does nothing if there are no tabs."]
    pub fn nctabbed_ensure_selected_header_visible(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Returns the currently selected tab, or NULL if there are no tabs."]
    pub fn nctabbed_selected(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the leftmost tab, or NULL if there are no tabs."]
    pub fn nctabbed_leftmost(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the number of tabs in the widget."]
    pub fn nctabbed_tabcount(nt: *mut nctabbed) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the plane associated to 'nt'."]
    pub fn nctabbed_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab content plane."]
    pub fn nctabbed_content_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab callback."]
    pub fn nctab_cb(t: *mut nctab) -> tabcb;
}
extern "C" {
    #[doc = " Returns the tab name. This is not a copy and it should not be stored."]
    pub fn nctab_name(t: *mut nctab) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Returns the width (in columns) of the tab's name."]
    pub fn nctab_name_width(t: *mut nctab) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the tab's user pointer."]
    pub fn nctab_userptr(t: *mut nctab) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Returns the tab to the right of 't'. This does not change which tab is selected."]
    pub fn nctab_next(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the tab to the left of 't'. This does not change which tab is selected."]
    pub fn nctab_prev(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Add a new tab to 'nt' with the given tab callback, name, and user pointer."]
    #[doc = " If both 'before' and 'after' are NULL, the tab is inserted after the selected"]
    #[doc = " tab. Otherwise, it gets put after 'after' (if not NULL) and before 'before'"]
    #[doc = " (if not NULL). If both 'after' and 'before' are given, they must be two"]
    #[doc = " neighboring tabs (the tab list is circular, so the last tab is immediately"]
    #[doc = " before the leftmost tab), otherwise the function returns NULL. If 'name' is"]
    #[doc = " NULL or a string containing illegal characters, the function returns NULL."]
    #[doc = " On all other failures the function also returns NULL. If it returns NULL,"]
    #[doc = " none of the arguments are modified, and the widget state is not altered."]
    pub fn nctabbed_add(
        nt: *mut nctabbed,
        after: *mut nctab,
        before: *mut nctab,
        tcb: tabcb,
        name: *const cty::c_char,
        opaque: *mut cty::c_void,
    ) -> *mut nctab;
}
extern "C" {
    #[doc = " Remove a tab 't' from 'nt'. Its neighboring tabs become neighbors to each"]
    #[doc = " other. If 't' if the selected tab, the tab after 't' becomes selected."]
    #[doc = " Likewise if 't' is the leftmost tab, the tab after 't' becomes leftmost."]
    #[doc = " If 't' is the only tab, there will no more be a selected or leftmost tab,"]
    #[doc = " until a new tab is added. Returns -1 if 't' is NULL, and 0 otherwise."]
    pub fn nctabbed_del(nt: *mut nctabbed, t: *mut nctab) -> cty::c_int;
}
extern "C" {
    #[doc = " Move 't' after 'after' (if not NULL) and before 'before' (if not NULL)."]
    #[doc = " If both 'after' and 'before' are NULL, the function returns -1, otherwise"]
    #[doc = " it returns 0."]
    pub fn nctab_move(
        nt: *mut nctabbed,
        t: *mut nctab,
        after: *mut nctab,
        before: *mut nctab,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become leftmost if needed."]
    pub fn nctab_move_right(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become the last tab if needed."]
    pub fn nctab_move_left(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Rotate the tabs of 'nt' right by 'amt' tabs, or '-amt' tabs left if 'amt' is"]
    #[doc = " negative. Tabs are rotated only by changing the leftmost tab; the selected tab"]
    #[doc = " stays the same. If there are no tabs, nothing happens."]
    pub fn nctabbed_rotate(nt: *mut nctabbed, amt: cty::c_int);
}
extern "C" {
    #[doc = " Select the tab after the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_next(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Select the tab before the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_prev(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Change the selected tab to be 't'. Returns the previously selected tab."]
    pub fn nctabbed_select(nt: *mut nctabbed, t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Write the channels for tab headers, the selected tab header, and the separator"]
    #[doc = " to '*hdrchan', '*selchan', and '*sepchan' respectively."]
    pub fn nctabbed_channels(
        nt: *mut nctabbed,
        hdrchan: *mut u64,
        selchan: *mut u64,
        sepchan: *mut u64,
    );
}
extern "C" {
    #[doc = " Returns the tab separator. This is not a copy and it should not be stored."]
    #[doc = " This can be NULL, if the separator was set to NULL in ncatbbed_create() or"]
    #[doc = " nctabbed_set_separator()."]
    pub fn nctabbed_separator(nt: *mut nctabbed) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Returns the tab separator width, or zero if there is no separator."]
    pub fn nctabbed_separator_width(nt: *mut nctabbed) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the tab headers channel for 'nt'."]
    pub fn nctabbed_set_hdrchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the selected tab header channel for 'nt'."]
    pub fn nctabbed_set_selchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab separator channel for 'nt'."]
    pub fn nctabbed_set_sepchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab callback function for 't'. Returns the previous tab callback."]
    pub fn nctab_set_cb(t: *mut nctab, newcb: tabcb) -> tabcb;
}
extern "C" {
    #[doc = " Change the name of 't'. Returns -1 if 'newname' is NULL, and 0 otherwise."]
    pub fn nctab_set_name(t: *mut nctab, newname: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the user pointer of 't'. Returns the previous user pointer."]
    pub fn nctab_set_userptr(t: *mut nctab, newopaque: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change the tab separator for 'nt'. Returns -1 if 'separator' is not NULL and"]
    #[doc = " is not a valid string, and 0 otherwise."]
    pub fn nctabbed_set_separator(nt: *mut nctabbed, separator: *const cty::c_char) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplot_options {
    #[doc = " channels for the maximum and minimum levels. linear or exponential"]
    #[doc = " interpolation will be applied across the domain between these two."]
    pub maxchannels: u64,
    pub minchannels: u64,
    #[doc = " styling used for the legend, if NCPLOT_OPTION_LABELTICKSD is set"]
    pub legendstyle: u16,
    #[doc = " number of \"pixels\" per row x column"]
    pub gridtype: ncblitter_e,
    #[doc = " independent variable can either be a contiguous range, or a finite set"]
    #[doc = " of keys. for a time range, say the previous hour sampled with second"]
    #[doc = " resolution, the independent variable would be the range [0..3600): 3600."]
    #[doc = " if rangex is 0, it is dynamically set to the number of columns."]
    pub rangex: cty::c_int,
    #[doc = " optional, printed by the labels"]
    pub title: *const cty::c_char,
    #[doc = " bitfield over NCPLOT_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncplot_options() {
    assert_eq!(
        ::core::mem::size_of::<ncplot_options>(),
        48usize,
        concat!("Size of: ", stringify!(ncplot_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncplot_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncplot_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).maxchannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(maxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).minchannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(minchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).legendstyle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(legendstyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).gridtype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(gridtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).rangex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(rangex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).title as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncplot_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Use the provided plane 'n' for plotting according to the options 'opts'. The"]
    #[doc = " plot will make free use of the entirety of the plane. For domain"]
    #[doc = " autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while"]
    #[doc = " ncdplot holds doubles."]
    pub fn ncuplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: u64,
        maxy: u64,
    ) -> *mut ncuplot;
}
extern "C" {
    pub fn ncdplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: f64,
        maxy: f64,
    ) -> *mut ncdplot;
}
extern "C" {
    #[doc = " Return a reference to the ncplot's underlying ncplane."]
    pub fn ncuplot_plane(n: *mut ncuplot) -> *mut ncplane;
}
extern "C" {
    pub fn ncdplot_plane(n: *mut ncdplot) -> *mut ncplane;
}
extern "C" {
    #[doc = " Add to or set the value corresponding to this x. If x is beyond the current"]
    #[doc = " x window, the x window is advanced to include x, and values passing beyond"]
    #[doc = " the window are lost. The first call will place the initial window. The plot"]
    #[doc = " will be redrawn, but notcurses_render() is not called."]
    pub fn ncuplot_add_sample(n: *mut ncuplot, x: u64, y: u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_add_sample(n: *mut ncdplot, x: u64, y: f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_set_sample(n: *mut ncuplot, x: u64, y: u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_set_sample(n: *mut ncdplot, x: u64, y: f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_sample(n: *const ncuplot, x: u64, y: *mut u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_sample(n: *const ncdplot, x: u64, y: *mut f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_destroy(n: *mut ncuplot);
}
extern "C" {
    pub fn ncdplot_destroy(n: *mut ncdplot);
}
pub type ncfdplane_callback = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        buf: *const cty::c_void,
        s: size_t,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
pub type ncfdplane_done_cb = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        fderrno: cty::c_int,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
#[doc = " read from an fd until EOF (or beyond, if follow is set), invoking the user's"]
#[doc = " callback each time. runs in its own context. on EOF or error, the finalizer"]
#[doc = " callback will be invoked, and the user ought destroy the ncfdplane. the"]
#[doc = " data is *not* guaranteed to be nul-terminated, and may contain arbitrary"]
#[doc = " zeroes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncfdplane_options {
    #[doc = " parameter provided to callbacks"]
    pub curry: *mut cty::c_void,
    #[doc = " keep reading after hitting end? (think tail -f)"]
    pub follow: bool,
    #[doc = " bitfield over NCOPTION_FDPLANE_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncfdplane_options() {
    assert_eq!(
        ::core::mem::size_of::<ncfdplane_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncfdplane_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncfdplane_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncfdplane_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).follow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(follow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncfdplane_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create an ncfdplane around the fd 'fd'. Consider this function to take"]
    #[doc = " ownership of the file descriptor, which will be closed in ncfdplane_destroy()."]
    pub fn ncfdplane_create(
        n: *mut ncplane,
        opts: *const ncfdplane_options,
        fd: cty::c_int,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncfdplane;
}
extern "C" {
    pub fn ncfdplane_plane(n: *mut ncfdplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncfdplane_destroy(n: *mut ncfdplane) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncsubproc_options {
    pub curry: *mut cty::c_void,
    #[doc = " restart this many seconds after an exit (watch)"]
    pub restart_period: u64,
    #[doc = " bitfield over NCOPTION_SUBPROC_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncsubproc_options() {
    assert_eq!(
        ::core::mem::size_of::<ncsubproc_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncsubproc_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncsubproc_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncsubproc_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncsubproc_options>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncsubproc_options>())).restart_period as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(restart_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncsubproc_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncsubproc_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " see exec(2). p-types use $PATH. e-type passes environment vars."]
    pub fn ncsubproc_createv(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvp(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvpe(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        env: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_plane(n: *mut ncsubproc) -> *mut ncplane;
}
extern "C" {
    pub fn ncsubproc_destroy(n: *mut ncsubproc) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a QR code at the current position on the plane. If there is insufficient"]
    #[doc = " room to draw the code here, or there is any other error, non-zero will be"]
    #[doc = " returned. Otherwise, the QR code \"version\" (size) is returned. The QR code"]
    #[doc = " is (version * 4 + 17) columns wide, and version * 4 + 17 rows tall (the"]
    #[doc = " properly-scaled values are written back to '*ymax' and '*xmax')."]
    pub fn ncplane_qrcode(
        n: *mut ncplane,
        ymax: *mut cty::c_int,
        xmax: *mut cty::c_int,
        data: *const cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreader_options {
    #[doc = " channels used for input"]
    pub tchannels: u64,
    #[doc = " attributes used for input"]
    pub tattrword: u32,
    #[doc = " bitfield of NCREADER_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncreader_options() {
    assert_eq!(
        ::core::mem::size_of::<ncreader_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncreader_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncreader_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncreader_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).tchannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(tchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).tattrword as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(tattrword)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " ncreaders provide freeform input in a (possibly multiline) region, supporting"]
    #[doc = " optional readline keybindings. takes ownership of 'n', destroying it on any"]
    #[doc = " error (ncreader_destroy() otherwise destroys the ncplane)."]
    pub fn ncreader_create(n: *mut ncplane, opts: *const ncreader_options) -> *mut ncreader;
}
extern "C" {
    #[doc = " empty the ncreader of any user input, and home the cursor."]
    pub fn ncreader_clear(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_plane(n: *mut ncreader) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncreader. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. Almost all inputs"]
    #[doc = " are relevant to an ncreader, save synthesized ones."]
    pub fn ncreader_offer_input(n: *mut ncreader, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Atttempt to move in the specified direction. Returns 0 if a move was"]
    #[doc = " successfully executed, -1 otherwise. Scrolling is taken into account."]
    pub fn ncreader_move_left(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_right(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_up(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_down(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    #[doc = " Destructively write the provided EGC to the current cursor location. Move"]
    #[doc = " the cursor as necessary, scrolling if applicable."]
    pub fn ncreader_write_egc(n: *mut ncreader, egc: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " return a heap-allocated copy of the current (UTF-8) contents."]
    pub fn ncreader_contents(n: *const ncreader) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " destroy the reader and its bound plane. if 'contents' is not NULL, the"]
    #[doc = " UTF-8 input will be heap-duplicated and written to 'contents'."]
    pub fn ncreader_destroy(n: *mut ncreader, contents: *mut *mut cty::c_char);
}
extern "C" {
    #[doc = " Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform,"]
    #[doc = " and subject to change. It includes geometry of all planes, from all piles."]
    pub fn notcurses_debug(nc: *const notcurses, debugfp: *mut FILE);
}
extern "C" {
    #[doc = " Dump selected configuration capabilities to 'debugfp'. Output is freeform,"]
    #[doc = " and subject to change."]
    pub fn notcurses_debug_caps(nc: *const notcurses, debugfp: *mut FILE);
}
extern "C" {
    #[doc = " Get the default *media* (not plot) blitter for this environment when using"]
    #[doc = " the specified scaling method. Currently, this means:"]
    #[doc = "  - if lacking UTF-8, NCBLIT_1x1"]
    #[doc = "  - otherwise, if not NCSCALE_STRETCH, NCBLIT_2x1"]
    #[doc = "  - otherwise, if sextants are not known to be good, NCBLIT_2x2"]
    #[doc = "  - otherwise NCBLIT_3x2"]
    #[doc = " NCBLIT_2x2 and NCBLIT_3x2 both distort the original aspect ratio, thus"]
    #[doc = " NCBLIT_2x1 is used outside of NCSCALE_STRETCH."]
    pub fn ncvisual_media_defblitter(nc: *const notcurses, scale: ncscale_e) -> ncblitter_e;
}
pub type ncdirectv = ncplane;
#[repr(C)]
#[derive(Debug)]
pub struct ncdirect {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialize a direct-mode Notcurses context on the connected terminal at 'fp'."]
    #[doc = " 'fp' must be a tty. You'll usually want stdout. Direct mode supports a"]
    #[doc = " limited subset of Notcurses routines which directly affect 'fp', and neither"]
    #[doc = " supports nor requires notcurses_render(). This can be used to add color and"]
    #[doc = " styling to text in the standard output paradigm. 'flags' is a bitmask over"]
    #[doc = " NCDIRECT_OPTION_*."]
    #[doc = " Returns NULL on error, including any failure initializing terminfo."]
    pub fn ncdirect_init(termtype: *const cty::c_char, fp: *mut FILE, flags: u64) -> *mut ncdirect;
}
extern "C" {
    #[doc = " The same as ncdirect_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn ncdirect_core_init(
        termtype: *const cty::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " Read a (heap-allocated) line of text using the Readline library Initializes"]
    #[doc = " Readline the first time it's called. For input to be echoed to the terminal,"]
    #[doc = " it is necessary that NCDIRECT_OPTION_INHIBIT_CBREAK be provided to"]
    #[doc = " ncdirect_init(). Returns NULL on error."]
    pub fn ncdirect_readline(nc: *mut ncdirect, prompt: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Direct mode. This API can be used to colorize and stylize output generated"]
    #[doc = " outside of notcurses, without ever calling notcurses_render(). These should"]
    #[doc = " not be intermixed with standard Notcurses rendering."]
    pub fn ncdirect_set_fg_rgb(nc: *mut ncdirect, rgb: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_rgb(nc: *mut ncdirect, rgb: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_palindex(nc: *mut ncdirect, pidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_palindex(nc: *mut ncdirect, pidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn ncdirect_palette_size(nc: *const ncdirect) -> cty::c_uint;
}
extern "C" {
    #[doc = " Output the string |utf8| according to the channels |channels|. Note that"]
    #[doc = " ncdirect_putstr() does not explicitly flush output buffers, so it will not"]
    #[doc = " necessarily be immediately visible."]
    pub fn ncdirect_putstr(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Formatted printing (plus alignment relative to the terminal). Returns the"]
    #[doc = " number of columns printed on success."]
    pub fn ncdirect_printf_aligned(
        n: *mut ncdirect,
        y: cty::c_int,
        align: ncalign_e,
        fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Force a flush. Returns 0 on success, -1 on failure."]
    pub fn ncdirect_flush(nc: *const ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_default(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_default(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the current number of columns/rows."]
    pub fn ncdirect_dim_x(nc: *const ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_dim_y(nc: *const ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " ncplane_styles_*() analogues"]
    pub fn ncdirect_set_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_on_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_off_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Deprecated forms of above."]
    pub fn ncdirect_styles_set(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_styles_on(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_styles_off(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Move the cursor in direct mode. -1 to retain current location on that axis."]
    pub fn ncdirect_cursor_move_yx(n: *mut ncdirect, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_enable(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_disable(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_up(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_left(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_right(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_down(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the cursor position, when supported. This requires writing to the"]
    #[doc = " terminal, and then reading from it. If the terminal doesn't reply, or"]
    #[doc = " doesn't reply in a way we understand, the results might be deleterious."]
    pub fn ncdirect_cursor_yx(
        n: *mut ncdirect,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Push or pop the cursor location to the terminal's stack. The depth of this"]
    #[doc = " stack, and indeed its existence, is terminal-dependent."]
    pub fn ncdirect_cursor_push(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_pop(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Display an image using the specified blitter and scaling. The image may"]
    #[doc = " be arbitrarily many rows -- the output will scroll -- but will only occupy"]
    #[doc = " the column of the cursor, and those to the right. The render/raster process"]
    #[doc = " can be split by using ncdirect_render_frame() and ncdirect_raster_frame()."]
    pub fn ncdirect_render_image(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        align: ncalign_e,
        blitter: ncblitter_e,
        scale: ncscale_e,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Clear the screen."]
    pub fn ncdirect_clear(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn ncdirect_canopen_images(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn ncdirect_canutf8(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " This function must successfully return before NCBLIT_PIXEL is available."]
    #[doc = " Returns -1 on error, 0 for no support, or 1 if pixel output is supported."]
    #[doc = " Must not be called concurrently with either input or rasterization."]
    pub fn ncdirect_check_pixel_support(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw horizontal/vertical lines using the specified channels, interpolating"]
    #[doc = " between them as we go. The EGC may not use more than one column. For a"]
    #[doc = " horizontal line, |len| cannot exceed the screen width minus the cursor's"]
    #[doc = " offset. For a vertical line, it may be as long as you'd like; the screen"]
    #[doc = " will scroll as necessary. All lines start at the current cursor position."]
    pub fn ncdirect_hline_interp(
        n: *mut ncdirect,
        egc: *const cty::c_char,
        len: cty::c_int,
        h1: u64,
        h2: u64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_vline_interp(
        n: *mut ncdirect,
        egc: *const cty::c_char,
        len: cty::c_int,
        h1: u64,
        h2: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, having"]
    #[doc = " dimensions |ylen|x|xlen|. See ncplane_box() for more information. The"]
    #[doc = " minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an"]
    #[doc = " array of 6 wide characters: UL, UR, LL, LR, HL, VL."]
    pub fn ncdirect_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        wchars: *const wchar_t,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the rounded box-drawing characters"]
    pub fn ncdirect_rounded_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the double box-drawing characters"]
    pub fn ncdirect_double_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts'"]
    #[doc = " of 0 for non-blocking operation, and otherwise a timespec to bound blocking."]
    #[doc = " Signals in sigmask (less several we handle internally) will be atomically"]
    #[doc = " masked and unmasked per ppoll(2). '*sigmask' should generally contain all"]
    #[doc = " signals. Returns a single Unicode code point, or (char32_t)-1 on error."]
    #[doc = " 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the"]
    #[doc = " return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn ncdirect_getc(
        n: *mut ncdirect,
        ts: *const timespec,
        sigmask: *mut sigset_t,
        ni: *mut ncinput,
    ) -> char32_t;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call ncdirect_getc_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn ncdirect_inputready_fd(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Release 'nc' and any associated resources. 0 on success, non-0 on failure."]
    pub fn ncdirect_stop(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Render an image using the specified blitter and scaling, but do not write"]
    #[doc = " the result. The image may be arbitrarily many rows -- the output will scroll"]
    #[doc = " -- but will only occupy the column of the cursor, and those to the right."]
    #[doc = " To actually write (and free) this, invoke ncdirect_raster_frame(). 'maxx'"]
    #[doc = " and 'maxy', if greater than 0, are used for scaling; the terminal's geometry"]
    #[doc = " is otherwise used."]
    pub fn ncdirect_render_frame(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        blitter: ncblitter_e,
        scale: ncscale_e,
        maxy: cty::c_int,
        maxx: cty::c_int,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Takes the result of ncdirect_render_frame() and writes it to the output."]
    pub fn ncdirect_raster_frame(
        n: *mut ncdirect,
        ncdv: *mut ncdirectv,
        align: ncalign_e,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_stream(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        streamer: ncstreamcb,
        vopts: *mut ncvisual_options,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
