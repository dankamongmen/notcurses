initSidebarItems({"constant":[["BC_BASE_MAX",""],["BC_DIM_MAX",""],["BC_SCALE_MAX",""],["BC_STRING_MAX",""],["BPREFIXCOLUMNS",""],["BPREFIXSTRLEN",""],["BRKINT",""],["BS0",""],["BS1",""],["BSDLY",""],["BUFSIZ",""],["CELL_ALPHA_BLEND",""],["CELL_ALPHA_HIGHCONTRAST",""],["CELL_ALPHA_OPAQUE",""],["CELL_ALPHA_TRANSPARENT",""],["CHARCLASS_NAME_MAX",""],["CLOCAL",""],["COLL_WEIGHTS_MAX",""],["CR0",""],["CR1",""],["CR2",""],["CR3",""],["CRDLY",""],["CREAD",""],["CS5",""],["CS6",""],["CS7",""],["CS8",""],["CSIZE",""],["CSTOPB",""],["ECHO",""],["ECHOE",""],["ECHOK",""],["ECHONL",""],["EOF",""],["EXIT_FAILURE",""],["EXIT_SUCCESS",""],["EXPR_NEST_MAX",""],["FF0",""],["FF1",""],["FFDLY",""],["FILENAME_MAX",""],["FOPEN_MAX",""],["ICANON",""],["ICRNL",""],["IEXTEN",""],["IGNBRK",""],["IGNCR",""],["IGNPAR",""],["IMAXBEL",""],["IOV_MAX",""],["IPREFIXCOLUMNS",""],["IPREFIXSTRLEN",""],["ISIG",""],["ISTRIP",""],["IUCLC",""],["IUTF8",""],["IXANY",""],["IXOFF",""],["IXON",""],["NCALPHA_BLEND",""],["NCALPHA_HIGHCONTRAST",""],["NCALPHA_OPAQUE",""],["NCALPHA_TRANSPARENT",""],["NCANGLESBL",""],["NCANGLESBR",""],["NCANGLESTL",""],["NCANGLESTR",""],["NCARROWANTICLOCKW",""],["NCARROWCIRCLEDW",""],["NCARROWDASHEDW",""],["NCARROWDOUBLEW",""],["NCARROWW",""],["NCASTERISKS5",""],["NCASTERISKS6",""],["NCASTERISKS8",""],["NCBLACKARROWHEADSW",""],["NCBLACKTRIANGLESW",""],["NCBOXASCII",""],["NCBOXASCIIW",""],["NCBOXCORNER_MASK",""],["NCBOXCORNER_SHIFT",""],["NCBOXDOUBLE",""],["NCBOXDOUBLEW",""],["NCBOXDRAWHEAVYW",""],["NCBOXDRAWW",""],["NCBOXGRAD_BOTTOM",""],["NCBOXGRAD_LEFT",""],["NCBOXGRAD_RIGHT",""],["NCBOXGRAD_TOP",""],["NCBOXHEAVY",""],["NCBOXHEAVYW",""],["NCBOXLIGHT",""],["NCBOXLIGHTW",""],["NCBOXMASK_BOTTOM",""],["NCBOXMASK_LEFT",""],["NCBOXMASK_RIGHT",""],["NCBOXMASK_TOP",""],["NCBOXOUTER",""],["NCBOXOUTERW",""],["NCBOXROUND",""],["NCBOXROUNDW",""],["NCBRAILLEEGCS",""],["NCCIRCULARARCSW",""],["NCCS",""],["NCDIAGONALSW",""],["NCDIGITSSUBW",""],["NCDIGITSSUPERW",""],["NCDIRECT_OPTION_INHIBIT_CBREAK",""],["NCDIRECT_OPTION_INHIBIT_SETLOCALE",""],["NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS",""],["NCDIRECT_OPTION_VERBOSE",""],["NCDIRECT_OPTION_VERY_VERBOSE",""],["NCEIGHTHSB",""],["NCEIGHTHSL",""],["NCEIGHTHSR",""],["NCEIGHTHST",""],["NCHALFBLOCKS",""],["NCKEY_ESC",""],["NCKEY_SPACE",""],["NCLIGHTARROWHEADSW",""],["NCMENU_OPTION_BOTTOM",""],["NCMENU_OPTION_HIDING",""],["NCOPTION_INHIBIT_SETLOCALE",""],["NCOPTION_NO_ALTERNATE_SCREEN",""],["NCOPTION_NO_CLEAR_BITMAPS",""],["NCOPTION_NO_FONT_CHANGES",""],["NCOPTION_NO_QUIT_SIGHANDLERS",""],["NCOPTION_NO_WINCH_SIGHANDLER",""],["NCOPTION_PRESERVE_CURSOR",""],["NCOPTION_SUPPRESS_BANNERS",""],["NCPALETTESIZE",""],["NCPLANE_OPTION_FIXED",""],["NCPLANE_OPTION_HORALIGNED",""],["NCPLANE_OPTION_MARGINALIZED",""],["NCPLANE_OPTION_VERALIGNED",""],["NCPLOT_OPTION_DETECTMAXONLY",""],["NCPLOT_OPTION_EXPONENTIALD",""],["NCPLOT_OPTION_LABELTICKSD",""],["NCPLOT_OPTION_NODEGRADE",""],["NCPLOT_OPTION_PRINTSAMPLE",""],["NCPLOT_OPTION_VERTICALI",""],["NCPROGBAR_OPTION_RETROGRADE",""],["NCQUADBLOCKS",""],["NCREADER_OPTION_CURSOR",""],["NCREADER_OPTION_HORSCROLL",""],["NCREADER_OPTION_NOCMDKEYS",""],["NCREADER_OPTION_VERSCROLL",""],["NCREEL_OPTION_CIRCULAR",""],["NCREEL_OPTION_INFINITESCROLL",""],["NCSEXBLOCKS",""],["NCSHADETRIANGLESW",""],["NCSTYLE_BLINK",""],["NCSTYLE_BOLD",""],["NCSTYLE_DIM",""],["NCSTYLE_INVIS",""],["NCSTYLE_ITALIC",""],["NCSTYLE_MASK",""],["NCSTYLE_NONE",""],["NCSTYLE_PROTECT",""],["NCSTYLE_REVERSE",""],["NCSTYLE_STANDOUT",""],["NCSTYLE_STRUCK",""],["NCSTYLE_UNDERCURL",""],["NCSTYLE_UNDERLINE",""],["NCTABBED_OPTION_BOTTOM",""],["NCVISUAL_OPTION_ADDALPHA",""],["NCVISUAL_OPTION_BLEND",""],["NCVISUAL_OPTION_CHILDPLANE",""],["NCVISUAL_OPTION_HORALIGNED",""],["NCVISUAL_OPTION_NODEGRADE",""],["NCVISUAL_OPTION_NOINTERPOLATE",""],["NCVISUAL_OPTION_VERALIGNED",""],["NCWHITECIRCLESW",""],["NCWHITESQUARESW",""],["NCWHITETRIANGLESW",""],["NC_BGDEFAULT_MASK",""],["NC_BG_ALPHA_MASK",""],["NC_BG_PALETTE",""],["NC_BG_RGB_MASK",""],["NC_FGDEFAULT_MASK",""],["NC_FG_ALPHA_MASK",""],["NC_FG_PALETTE",""],["NC_FG_RGB_MASK",""],["NC_NOBACKGROUND_MASK",""],["OCRNL",""],["OFDEL",""],["OFILL",""],["OLCUC",""],["ONLCR",""],["ONLRET",""],["ONOCR",""],["OPOST",""],["PARENB",""],["PARMRK",""],["PARODD",""],["PATH_MAX",""],["PIPE_BUF",""],["POLLERR",""],["POLLHUP",""],["POLLIN",""],["POLLNVAL",""],["POLLOUT",""],["POLLPRI",""],["POLLRDBAND",""],["POLLRDNORM",""],["POLLWRBAND",""],["POLLWRNORM",""],["PREFIXCOLUMNS",""],["PREFIXSTRLEN",""],["PTHREAD_DESTRUCTOR_ITERATIONS",""],["PTHREAD_KEYS_MAX",""],["PTHREAD_STACK_MIN",""],["PTRDIFF_MAX",""],["PTRDIFF_MIN",""],["P_tmpdir",""],["_BYTESWAP_H",""],["_CTYPE_H",""],["_ENDIAN_H",""],["_FEATURES_H",""],["_GETOPT_CORE_H",""],["_GETOPT_POSIX_H",""],["_HAVE_STRUCT_TERMIOS_C_ISPEED",""],["_HAVE_STRUCT_TERMIOS_C_OSPEED",""],["_IOFBF",""],["_IOLBF",""],["_IONBF",""],["_IO_EOF_SEEN",""],["_IO_ERR_SEEN",""],["_IO_USER_LOCK",""],["_LIBC_LIMITS_H_",""],["_NETINET_IN_H",""],["_NSIG",""],["_SS_SIZE",""],["_STDC_PREDEF_H",""],["_STDINT_H",""],["_STDIO_H",""],["_STDLIB_H",""],["_STRING_H",""],["_STRUCT_TIMESPEC",""],["_SYS_CDEFS_H",""],["_SYS_POLL_H",""],["_SYS_SOCKET_H",""],["_SYS_TYPES_H",""],["_TERMIOS_H",""],["_TIME_H",""],["_WCHAR_H",""],["_WINT_T",""],["_XOPEN_IOV_MAX",""],["_XOPEN_LIM_H",""],["____FILE_defined",""],["_____fpos64_t_defined",""],["_____fpos_t_defined",""],["____mbstate_t_defined",""],["__bool_true_false_are_defined",""],["__clock_t_defined",""],["__clockid_t_defined",""],["__glibc_c99_flexarr_available",""],["__iovec_defined",""],["__ldiv_t_defined",""],["__lldiv_t_defined",""],["__mbstate_t_defined",""],["__sig_atomic_t_defined",""],["__sigset_t_defined",""],["__socket_type_SOCK_CLOEXEC","Atomically set close-on-exec flag for the new descriptor(s)."],["__socket_type_SOCK_DCCP","Datagram Congestion Control Protocol."],["__socket_type_SOCK_DGRAM","Connectionless, unreliable datagrams of fixed maximum length."],["__socket_type_SOCK_NONBLOCK","Atomically mark descriptor(s) as non-blocking."],["__socket_type_SOCK_PACKET","Linux specific way of getting packets at the dev level.  For writing rarp and other similar things on the user level."],["__socket_type_SOCK_RAW","Raw protocol interface."],["__socket_type_SOCK_RDM","Reliably-delivered messages."],["__socket_type_SOCK_SEQPACKET","Sequenced, reliable, connection-based, datagrams of fixed maximum length."],["__socket_type_SOCK_STREAM","Sequenced, reliable, connection-based byte streams."],["__struct_FILE_defined",""],["__struct_tm_defined",""],["__time_t_defined",""],["__timer_t_defined",""],["__wint_t_defined",""],["false_",""],["ncalign_e_NCALIGN_CENTER",""],["ncalign_e_NCALIGN_LEFT",""],["ncalign_e_NCALIGN_RIGHT",""],["ncalign_e_NCALIGN_UNALIGNED",""],["ncblitter_e_NCBLIT_1x1","space, compatible with ASCII"],["ncblitter_e_NCBLIT_2x1","halves + 1x1 (space)     â–„â–€"],["ncblitter_e_NCBLIT_2x2","quadrants + 2x1          â–—â– â––â–€â–Ÿâ–Œâ–™"],["ncblitter_e_NCBLIT_3x2","sextants (NOT 2x2)     ğŸ¬€ğŸ¬ğŸ¬‚ğŸ¬ƒğŸ¬„ğŸ¬…ğŸ¬†ğŸ¬‡ğŸ¬ˆğŸ¬‰ğŸ¬ŠğŸ¬‹ğŸ¬ŒğŸ¬ğŸ¬ğŸ¬ğŸ¬ğŸ¬‘ğŸ¬’ğŸ¬“ğŸ¬”ğŸ¬•ğŸ¬–ğŸ¬—ğŸ¬˜ğŸ¬™ğŸ¬šğŸ¬›ğŸ¬œğŸ¬ğŸ¬"],["ncblitter_e_NCBLIT_4x1","four vertical levels     â–ˆâ–†â–„â–‚"],["ncblitter_e_NCBLIT_8x1","eight vertical levels    â–ˆâ–‡â–†â–…â–„â–ƒâ–‚â–"],["ncblitter_e_NCBLIT_BRAILLE","4 rows, 2 cols (braille) â¡€â¡„â¡†â¡‡â¢€â£€â£„â£†â£‡â¢ â£ â£¤â£¦â£§â¢°â£°â£´â£¶â£·â¢¸â£¸â£¼â£¾â£¿"],["ncblitter_e_NCBLIT_DEFAULT","let the ncvisual pick"],["ncblitter_e_NCBLIT_PIXEL","pixel graphics"],["ncloglevel_e_NCLOGLEVEL_DEBUG","this is honestly a bit much"],["ncloglevel_e_NCLOGLEVEL_ERROR","we canâ€™t keep doing this, but we can do other things"],["ncloglevel_e_NCLOGLEVEL_FATAL","weâ€™re hanging around, but weâ€™ve had a horrible fault"],["ncloglevel_e_NCLOGLEVEL_INFO","â€œstandard informationâ€"],["ncloglevel_e_NCLOGLEVEL_PANIC","print diagnostics related to catastrophic failure"],["ncloglevel_e_NCLOGLEVEL_SILENT","default. print nothing once fullscreen service begins"],["ncloglevel_e_NCLOGLEVEL_TRACE","thereâ€™s probably a better way to do what you want"],["ncloglevel_e_NCLOGLEVEL_VERBOSE","â€œdetailed informationâ€"],["ncloglevel_e_NCLOGLEVEL_WARNING","you probably donâ€™t want whatâ€™s happening to happen"],["ncscale_e_NCSCALE_NONE",""],["ncscale_e_NCSCALE_NONE_HIRES",""],["ncscale_e_NCSCALE_SCALE",""],["ncscale_e_NCSCALE_SCALE_HIRES",""],["ncscale_e_NCSCALE_STRETCH",""],["true_",""]],"fn":[["ncblit_bgrx","Same as ncblit_rgba(), but for BGRx."],["ncblit_rgb_loose","Supply an alpha value [0..255] to be applied throughout. linesize must be a multiple of 4 for this RGBx data."],["ncblit_rgb_packed","Supply an alpha value [0..255] to be applied throughout."],["ncblit_rgba","Blit a flat array â€˜dataâ€™ of RGBA 32-bit values to the ncplane â€˜vopts->nâ€™, which mustnâ€™t be NULL. the blit begins at â€˜vopts->yâ€™ and â€˜vopts->xâ€™ relative to the specified plane. Each source row ought occupy â€˜linesizeâ€™ bytes (this might be greater than â€˜vopts->lenxâ€™ * 4 due to padding or partial blits). A subregion of the input can be specified with the â€˜begyâ€™xâ€™begxâ€™ and â€˜lenyâ€™xâ€™lenxâ€™ fields from â€˜voptsâ€™. Returns the number of pixels blitted, or -1 on error."],["nccell_duplicate","Duplicate â€˜câ€™ into â€˜targâ€™; both must be/will be bound to â€˜nâ€™. Returns -1 on failure, and 0 on success."],["nccell_extended_gcluster","return a pointer to the NUL-terminated EGC referenced by â€˜câ€™. this pointer can be invalidated by any further operation on the plane â€˜nâ€™, soâ€¦watch out!"],["nccell_load","Breaks the UTF-8 string in â€˜gclusterâ€™ down, setting up the nccell â€˜câ€™. Returns the number of bytes copied out of â€˜gclusterâ€™, or -1 on failure. The styling of the cell is left untouched, but any resources are released."],["nccell_release","Release resources held by the nccell â€˜câ€™."],["nccell_width",""],["nccells_double_box",""],["nccells_rounded_box",""],["ncdirect_box","Draw a box with its upper-left corner at the current cursor position, having dimensions |ylen|x|xlen|. See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an array of 6 wide characters: UL, UR, LL, LR, HL, VL."],["ncdirect_canget_cursor","Is there support for acquiring the cursorâ€™s current position? Requires the u7 terminfo capability, and that we are connected to an actual terminal."],["ncdirect_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["ncdirect_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["ncdirect_capabilities",""],["ncdirect_check_pixel_support","Can we blit pixel-accurate bitmaps?"],["ncdirect_clear","Clear the screen."],["ncdirect_core_init","The same as ncdirect_init(), but without any multimedia functionality, allowing for a svelter binary. Link with notcurses-core if this is used."],["ncdirect_cursor_disable",""],["ncdirect_cursor_down",""],["ncdirect_cursor_enable",""],["ncdirect_cursor_left",""],["ncdirect_cursor_move_yx","Move the cursor in direct mode. -1 to retain current location on that axis."],["ncdirect_cursor_pop",""],["ncdirect_cursor_push","Push or pop the cursor location to the terminalâ€™s stack. The depth of this stack, and indeed its existence, is terminal-dependent."],["ncdirect_cursor_right",""],["ncdirect_cursor_up",""],["ncdirect_cursor_yx","Get the cursor position, when supported. This requires writing to the terminal, and then reading from it. If the terminal doesnâ€™t reply, or doesnâ€™t reply in a way we understand, the results might be deleterious."],["ncdirect_detected_terminal","Capabilites"],["ncdirect_dim_x","Get the current number of columns/rows."],["ncdirect_dim_y",""],["ncdirect_double_box","ncdirect_box() with the double box-drawing characters"],["ncdirect_flush","Force a flush. Returns 0 on success, -1 on failure."],["ncdirect_get","Provide a NULL â€˜tsâ€™ to block at length, a â€˜tsâ€™ of 0 for non-blocking operation, and otherwise a timespec to bound blocking. Returns a single Unicode code point, or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed, the return value is the â€˜idâ€™ field from that event. â€˜niâ€™ may be NULL."],["ncdirect_getc","Deprecated, to be removed for ABI3. Use ncdirect_get() in new code."],["ncdirect_hline_interp","Draw horizontal/vertical lines using the specified channels, interpolating between them as we go. The EGC may not use more than one column. For a horizontal line, |len| cannot exceed the screen width minus the cursorâ€™s offset. For a vertical line, it may be as long as youâ€™d like; the screen will scroll as necessary. All lines start at the current cursor position."],["ncdirect_init","Initialize a direct-mode Notcurses context on the connected terminal at â€˜fpâ€™. â€˜fpâ€™ must be a tty. Youâ€™ll usually want stdout. Direct mode supports a limited subset of Notcurses routines which directly affect â€˜fpâ€™, and neither supports nor requires notcurses_render(). This can be used to add color and styling to text in the standard output paradigm. â€˜flagsâ€™ is a bitmask over NCDIRECT_OPTION_*. Returns NULL on error, including any failure initializing terminfo."],["ncdirect_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call ncdirect_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["ncdirect_off_styles",""],["ncdirect_on_styles",""],["ncdirect_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["ncdirect_printf_aligned","Formatted printing (plus alignment relative to the terminal). Returns the number of columns printed on success."],["ncdirect_putegc","Output a single EGC (this might be several characters) from |utf8|, according to the channels |channels|. On success, the number of columns thought to have been used is returned, and if |sbytes| is not NULL, the number of bytes consumed will be written there."],["ncdirect_putstr","Output the string |utf8| according to the channels |channels|. Note that ncdirect_putstr() does not explicitly flush output buffers, so it will not necessarily be immediately visible."],["ncdirect_raster_frame","Takes the result of ncdirect_render_frame() and writes it to the output, freeing it on all paths."],["ncdirect_readline","Read a (heap-allocated) line of text using the Readline library Initializes Readline the first time itâ€™s called. For input to be echoed to the terminal, it is necessary that NCDIRECT_OPTION_INHIBIT_CBREAK be provided to ncdirect_init(). Returns NULL on error."],["ncdirect_render_frame","Render an image using the specified blitter and scaling, but do not write the result. The image may be arbitrarily many rows â€“ the output will scroll â€“ but will only occupy the column of the cursor, and those to the right. To actually write (and free) this, invoke ncdirect_raster_frame(). â€˜maxxâ€™ and â€˜maxyâ€™ (cell geometry, not pixel), if greater than 0, are used for scaling; the terminalâ€™s geometry is otherwise used."],["ncdirect_render_image","Display an image using the specified blitter and scaling. The image may be arbitrarily many rows â€“ the output will scroll â€“ but will only occupy the column of the cursor, and those to the right. The render/raster process can be split by using ncdirect_render_frame() and ncdirect_raster_frame()."],["ncdirect_rounded_box","ncdirect_box() with the rounded box-drawing characters"],["ncdirect_set_bg_default",""],["ncdirect_set_bg_palindex",""],["ncdirect_set_bg_rgb",""],["ncdirect_set_fg_default",""],["ncdirect_set_fg_palindex",""],["ncdirect_set_fg_rgb","Direct mode. This API can be used to colorize and stylize output generated outside of notcurses, without ever calling notcurses_render(). These should not be intermixed with standard Notcurses rendering."],["ncdirect_set_styles","ncplane_styles_*() analogues"],["ncdirect_stop","Release â€˜ncâ€™ and any associated resources. 0 on success, non-0 on failure."],["ncdirect_stream","Load successive frames from a file, invoking â€˜streamerâ€™ on each."],["ncdirect_styles",""],["ncdirect_styles_off",""],["ncdirect_styles_on",""],["ncdirect_styles_set","Deprecated forms of above."],["ncdirect_supported_styles","Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only indicated as supported if the terminal can support it together with color. For more information, see the â€œncvâ€ capability in terminfo(5)."],["ncdirect_vline_interp",""],["ncdirectf_free","Free a ncdirectf returned from ncdirectf_from_file()."],["ncdirectf_from_file","Load media from disk, but do not yet render it (presumably because you want to get its geometry via ncdirectf_geom(), or to use the same file with ncdirect_render_loaded_frame() multiple times). You must destroy the result with ncdirectf_free();"],["ncdirectf_geom","Having loaded the frame â€˜frameâ€™, get the geometry of a potential render."],["ncdirectf_render","Same as ncdirect_render_frame(), except â€˜frameâ€™ must already have been loaded. A loaded frame may be rendered in different ways before it is destroyed."],["ncdplot_add_sample",""],["ncdplot_create",""],["ncdplot_destroy",""],["ncdplot_plane",""],["ncdplot_sample",""],["ncdplot_set_sample",""],["ncfadectx_free","Release the resources associated with â€˜nctxâ€™."],["ncfadectx_iterations","Return the number of iterations through which â€˜nctxâ€™ will fade."],["ncfadectx_setup","Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."],["ncfdplane_create","Create an ncfdplane around the fd â€˜fdâ€™. Consider this function to take ownership of the file descriptor, which will be closed in ncfdplane_destroy()."],["ncfdplane_destroy",""],["ncfdplane_plane",""],["ncmenu_create","Create a menu with the specified options, bound to the specified plane."],["ncmenu_destroy","Destroy a menu created with ncmenu_create()."],["ncmenu_item_set_status","Disable or enable a menu item. Returns 0 if the item was found."],["ncmenu_mouse_selected","Return the item description corresponding to the mouse click â€˜clickâ€™. The item must be on an actively unrolled section, and the click must be in the area of a valid item. If â€˜niâ€™ is not NULL, and the selected item has a shortcut, â€˜niâ€™ will be filled in with the shortcut."],["ncmenu_nextitem","Move to the previous/next item within the currently unrolled section. If no section is unrolled, the first section will be unrolled."],["ncmenu_nextsection","Unroll the previous/next section (relative to current unrolled). If no section is unrolled, the first section will be unrolled."],["ncmenu_offer_input","Offer the input to the ncmenu. If itâ€™s relevant, this function returns true, and the input ought not be processed further. If itâ€™s irrelevant to the menu, false is returned. Relevant inputs include:"],["ncmenu_plane","Return the ncplane backing this ncmenu."],["ncmenu_previtem",""],["ncmenu_prevsection",""],["ncmenu_rollup","Roll up any unrolled menu section, and hide the menu if using hiding."],["ncmenu_selected","Return the selected item description, or NULL if no section is unrolled. If â€˜niâ€™ is not NULL, and the selected item has a shortcut, â€˜niâ€™ will be filled in with that shortcutâ€“this can allow faster matching."],["ncmenu_unroll","Unroll the specified menu section, making the menu visible if it was invisible, and rolling up any menu section that is already unrolled."],["ncmetric","Floating-point is never used, because an IEEE758 double can only losslessly represent integers through 2^53-1."],["ncmultiselector_create",""],["ncmultiselector_destroy","Destroy the ncmultiselector."],["ncmultiselector_offer_input","Offer the input to the ncmultiselector. If itâ€™s relevant, this function returns true, and the input ought not be processed further. If itâ€™s irrelevant to the multiselector, false is returned. Relevant inputs include:"],["ncmultiselector_plane","Return a reference to the ncmultiselectorâ€™s underlying ncplane."],["ncmultiselector_selected","Return selected vector. An array of bools must be provided, along with its length. If that length doesnâ€™t match the itemcount, it is an error."],["ncpalette_free","Free the palette store â€˜pâ€™."],["ncpalette_new","Create a new palette store. It will be initialized with notcursesâ€™ best knowledge of the currently configured palette. The palette upon startup cannot be reliably detected, sadly."],["ncpalette_use","Attempt to configure the terminal with the provided palette â€˜pâ€™. Does not transfer ownership of â€˜pâ€™; ncpalette_free() can (ought) still be called."],["ncpile_bottom","Return the bottommost plane of the pile containing â€˜nâ€™."],["ncpile_create","Same as ncplane_create(), but creates a new pile. The returned plane will be the top, bottom, and root of this new pile."],["ncpile_rasterize","Make the physical screen match the last rendered frame from the pile of which â€˜nâ€™ is a part. This is a blocking call. Donâ€™t call this before the pile has been rendered (doing so will likely result in a blank screen)."],["ncpile_render","Renders the pile of which â€˜nâ€™ is a part. Rendering this pile again will blow away the render. To actually write out the render, call ncpile_rasterize()."],["ncpile_render_to_buffer","Perform the rendering and rasterization portion of ncpile_render() and ncpile_rasterize(), but do not write the resulting buffer out to the terminal. Using this function, the user can control the writeout process. The returned buffer must be freed by the caller."],["ncpile_render_to_file","Write the last rendered frame, in its entirety, to â€˜fpâ€™. If notcurses_render() has not yet been called, nothing will be written."],["ncpile_top","Return the topmost plane of the pile containing â€˜nâ€™."],["ncplane_above","Return the plane above this one, or NULL if this is at the top."],["ncplane_abs_x",""],["ncplane_abs_y",""],["ncplane_abs_yx","Get the origin of plane â€˜nâ€™ relative to its pile. Either or both of â€˜xâ€™ and â€˜yâ€™ may be NULL."],["ncplane_as_rgba","Create an RGBA flat array from the selected region of the ncplane â€˜ncâ€™. Start at the planeâ€™s â€˜begyâ€™xâ€™begxâ€™ coordinate (which must lie on the plane), continuing for â€˜lenyâ€™xâ€™lenxâ€™ cells. Either or both of â€˜lenyâ€™ and â€˜lenxâ€™ can be specified as -1 to go through the boundary of the plane. Only glyphs from the specified ncblitset may be present. If â€˜pxdimyâ€™ and/or â€˜pxdimxâ€™ are non-NULL, they will be filled in with the pixel geometry."],["ncplane_at_cursor","Retrieve the current contents of the cell under the cursor. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to â€˜stylemaskâ€™ and â€˜channelsâ€™, respectively."],["ncplane_at_cursor_cell","Retrieve the current contents of the cell under the cursor into â€˜câ€™. This cell is invalidated if the associated plane is destroyed. Returns the number of bytes in the EGC, or -1 on error."],["ncplane_at_yx","Retrieve the current contents of the specified cell. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to â€˜stylemaskâ€™ and â€˜channelsâ€™, respectively. The return represents how the cell will be used during rendering, and thus integrates any base cell where appropriate. If called upon the secondary columns of a wide glyph, the EGC will be returned (i.e. this function does not distinguish between the primary and secondary columns of a wide glyph)."],["ncplane_at_yx_cell","Retrieve the current contents of the specified cell into â€˜câ€™. This cell is invalidated if the associated plane is destroyed. Returns the number of bytes in the EGC, or -1 on error. Unlike ncplane_at_yx(), when called upon the secondary columns of a wide glyph, the return can be distinguished from the primary column (nccell_wide_right_p(c) will return true)."],["ncplane_base","Extract the ncplaneâ€™s base nccell into â€˜câ€™. The reference is invalidated if â€˜ncpâ€™ is destroyed."],["ncplane_below","Return the plane below this one, or NULL if this is at the bottom."],["ncplane_boundlist","Get the head of the list of planes bound to â€˜nâ€™."],["ncplane_box","Draw a box with its upper-left corner at the current cursor position, and its lower-right corner at â€˜ystopâ€™xâ€™xstopâ€™. The 6 cells provided are used to draw the upper-left, ur, ll, and lr corners, then the horizontal and vertical lines. â€˜ctlwordâ€™ is defined in the least significant byte, where bits [7, 4] are a gradient mask, and [3, 0] are a border mask:"],["ncplane_center_abs",""],["ncplane_channels","Get the current channels or attribute word for ncplane â€˜nâ€™."],["ncplane_contents","Create a flat string from the EGCs of the selected region of the ncplane â€˜nâ€™. Start at the planeâ€™s â€˜begyâ€™xâ€™begxâ€™ coordinate (which must lie on the plane), continuing for â€˜lenyâ€™xâ€™lenxâ€™ cells. Either or both of â€˜lenyâ€™ and â€˜lenxâ€™ can be specified as -1 to go through the boundary of the plane."],["ncplane_create","Create a new ncplane bound to plane â€˜nâ€™, at the offset â€˜yâ€™xâ€™xâ€™ (relative to the origin of â€˜nâ€™) and the specified size. The number of â€˜rowsâ€™ and â€˜colsâ€™ must both be positive. This plane is initially at the top of the z-buffer, as if ncplane_move_top() had been called on it. The void* â€˜userptrâ€™ can be retrieved (and reset) later. A â€˜nameâ€™ can be set, used in debugging."],["ncplane_cursor_move_rel","Move the cursor relative to the current cursor position (the cursor neednâ€™t be visible). Returns -1 on error, including target position exceeding the planeâ€™s dimensions."],["ncplane_cursor_move_yx","Move the cursor to the specified position (the cursor neednâ€™t be visible). Pass -1 as either coordinate to hold that axis constant. Returns -1 if the move would place the cursor outside the plane."],["ncplane_cursor_yx","Get the current position of the cursor within n. y and/or x may be NULL."],["ncplane_destroy","Destroy the specified ncplane. None of its contents will be visible after the next call to notcurses_render(). It is an error to attempt to destroy the standard plane."],["ncplane_dim_yx","Return the dimensions of this ncplane."],["ncplane_dup","Duplicate an existing ncplane. The new plane will have the same geometry, will duplicate all content, and will start with the same rendering state. The new plane will be immediately above the old one on the z axis, and will be bound to the same parent. Bound planes are not duplicated; the new plane is bound to the parent of â€˜nâ€™, but has no bound planes."],["ncplane_erase","Erase every cell in the ncplane (each cell is initialized to the null glyph and the default channels/styles). All cells associated with this ncplane are invalidated, and must not be used after the call, excluding the base cell. The cursor is homed. The planeâ€™s active attributes are unaffected."],["ncplane_erase_region","Erase every cell in the region starting at {ystart, xstart} and having size {ylen, xlen}. It is an error if any of ystart, xstart, ylen, or xlen is negative. A value of 0 may be provided for ylen and/or xlen, meaning to erase everything along that dimension. It is an error if ystart + ylen or xstart + xlen is not in the plane."],["ncplane_fadein","Fade the ncplane in over the specified time. Load the ncplane with the target cells without rendering, then call this function. When itâ€™s done, the ncplane will have reached the target levels, starting from zeroes."],["ncplane_fadein_iteration","Fade in through â€˜iterâ€™ iterations, where â€˜iterâ€™ < â€˜ncfadectx_iterations(nctx)â€™."],["ncplane_fadeout","Fade the ncplane out over the provided time, calling â€˜faderâ€™ at each iteration. Requires a terminal which supports truecolor, or at least palette modification (if the terminal uses a palette, our ability to fade planes is limited, and affected by the complexity of the rest of the screen)."],["ncplane_fadeout_iteration","Fade out through â€˜iterâ€™ iterations, where â€˜iterâ€™ < â€˜ncfadectx_iterations(nctx)â€™."],["ncplane_format","Set the given style throughout the specified region, keeping content and channels unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_gradient","Draw a gradient with its upper-left corner at the current cursor position, stopping at â€˜ystopâ€™xâ€™xstopâ€™. The glyph composed of â€˜egcâ€™ and â€˜stylemaskâ€™ is used for all cells. The channels specified by â€˜ulâ€™, â€˜urâ€™, â€˜llâ€™, and â€˜lrâ€™ are composed into foreground and background gradients. To do a vertical gradient, â€˜ulâ€™ ought equal â€˜urâ€™ and â€˜llâ€™ ought equal â€˜lrâ€™. To do a horizontal gradient, â€˜ulâ€™ ought equal â€˜llâ€™ and â€˜urâ€™ ought equal â€˜ulâ€™. To color everything the same, all four channels should be equivalent. The resulting alpha values are equal to incoming alpha values. Returns the number of cells filled on success, or -1 on failure."],["ncplane_greyscale","Convert the planeâ€™s content to greyscale."],["ncplane_highgradient","Do a high-resolution gradient using upper blocks and synced backgrounds. This doubles the number of vertical gradations, but restricts you to half blocks (appearing to be full blocks). Returns the number of cells filled on success, or -1 on error."],["ncplane_highgradient_sized","ncplane_gradent_sized() meets ncplane_highgradient()."],["ncplane_hline_interp","Draw horizontal or vertical lines using the specified cell, starting at the current cursor position. The cursor will end at the cell following the last cell output (even, perhaps counter-intuitively, when drawing vertical lines), just as if ncplane_putc() was called at that spot. Return the number of cells drawn on success. On error, return the negative number of cells drawn."],["ncplane_home","Move the cursor to 0, 0. Canâ€™t fail."],["ncplane_mergedown","Merge the ncplane â€˜srcâ€™ down onto the ncplane â€˜dstâ€™. This is most rigorously defined as â€œwrite to â€˜dstâ€™ the frame that would be rendered were the entire stack made up only of the specified subregion of â€˜srcâ€™ and, below it, the subregion of â€˜dstâ€™ having the specified origin. Merging is independent of the position of â€˜srcâ€™ viz â€˜dstâ€™ on the z-axis. It is an error to define a subregion of zero area, or that is not entirely contained within â€˜srcâ€™. It is an error to define a target origin such that the projected subregion is not entirely contained within â€˜dstâ€™.  Behavior is undefined if â€˜srcâ€™ and â€˜dstâ€™ are equivalent. â€˜dstâ€™ is modified, but â€˜srcâ€™ remains unchanged. neither â€˜srcâ€™ nor â€˜dstâ€™ may have sprixels."],["ncplane_mergedown_simple","Merge the entirety of â€˜srcâ€™ down onto the ncplane â€˜dstâ€™. If â€˜srcâ€™ does not intersect with â€˜dstâ€™, â€˜dstâ€™ will not be changed, but it is not an error."],["ncplane_move_above","Splice ncplane â€˜nâ€™ out of the z-buffer, and reinsert it above â€˜aboveâ€™. Returns non-zero if â€˜nâ€™ is already in the desired location. â€˜nâ€™ and â€˜aboveâ€™ must not be the same plane."],["ncplane_move_below","Splice ncplane â€˜nâ€™ out of the z-buffer, and reinsert it below â€˜belowâ€™. Returns non-zero if â€˜nâ€™ is already in the desired location. â€˜nâ€™ and â€˜belowâ€™ must not be the same plane."],["ncplane_move_bottom",""],["ncplane_move_top","Splice ncplane â€˜nâ€™ out of the z-buffer, and reinsert it at the top or bottom."],["ncplane_move_yx","Move this plane relative to the standard plane, or the plane to which it is bound (if it is bound to a plane). It is an error to attempt to move the standard plane."],["ncplane_new","This function will be removed in ABI3 in favor of ncplane_create(). It persists in ABI2 only for backwards compatibility."],["ncplane_notcurses","Extract the Notcurses context to which this plane is attached."],["ncplane_notcurses_const",""],["ncplane_off_styles","Remove the specified styles from the ncplaneâ€™s existing spec."],["ncplane_on_styles","Add the specified styles to the ncplaneâ€™s existing spec."],["ncplane_parent","Get the plane to which the plane â€˜nâ€™ is bound, if any."],["ncplane_parent_const",""],["ncplane_pixelgeom","Retrieve pixel geometry for the display region (â€˜pxyâ€™, â€˜pxxâ€™), each cell (â€˜celldimyâ€™, â€˜celldimxâ€™), and the maximum displayable bitmap (â€˜maxbmapyâ€™, â€˜maxbmapxâ€™). If bitmaps are not supported, â€˜maxbmapyâ€™ and â€˜maxbmapxâ€™ will be 0. Any of the geometry arguments may be NULL."],["ncplane_polyfill_yx","Starting at the specified coordinate, if its glyph is different from that of â€˜câ€™, â€˜câ€™ is copied into it, and the original glyph is considered the fill target. We do the same to all cardinally-connected cells having this same fill target. Returns the number of cells polyfilled. An invalid initial y, x is an error. Returns the number of cells filled, or -1 on error."],["ncplane_pulse","Pulse the plane in and out until the callback returns non-zero, relying on the callback â€˜faderâ€™ to initiate rendering. â€˜tsâ€™ defines the half-period (i.e. the transition from black to full brightness, or back again). Proper use involves preparing (but not rendering) an ncplane, then calling ncplane_pulse(), which will fade in from black to the specified colors."],["ncplane_putc_yx","Replace the cell at the specified coordinates with the provided cell â€˜câ€™, and advance the cursor by the width of the cell (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. â€˜câ€™ must already be associated with â€˜nâ€™. On failure, -1 is returned."],["ncplane_putchar_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putegc_yx","Replace the cell at the specified coordinates with the provided EGC, and advance the cursor by the width of the cluster (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. On failure, -1 is returned. The number of bytes converted from gclust is written to â€˜sbytesâ€™ if non-NULL."],["ncplane_putnstr_aligned",""],["ncplane_putnstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error. No more than â€˜sâ€™ bytes will be written."],["ncplane_putstr_aligned",""],["ncplane_putstr_stained","Replace a stringâ€™s worth of glyphs at the current cursor location, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error."],["ncplane_puttext","Write the specified text to the plane, breaking lines sensibly, beginning at the specified line. Returns the number of columns written. When breaking a line, the line will be cleared to the end of the plane (the last line will not be so cleared). The number of bytes written from the input is written to â€˜*bytesâ€™ if it is not NULL. Cleared columns are included in the return value, but not included in the number of bytes written. Leaves the cursor at the end of output. A partial write will be accomplished as far as it can; determine whether the write completed by inspecting â€˜*bytesâ€™. Can output to multiple rows even in the absence of scrolling, but not more rows than are available. With scrolling enabled, arbitrary amounts of data can be emitted. All provided whitespace is preserved â€“ ncplane_puttext() followed by an appropriate ncplane_contents() will read back the original output."],["ncplane_putwegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putwstr_stained",""],["ncplane_qrcode","Draw a QR code at the current position on the plane. If there is insufficient room to draw the code here, or there is any other error, non-zero will be returned. Otherwise, the QR code â€œversionâ€ (size) is returned. The QR code is (version * 4 + 17) columns wide, and âŒˆversion * 4 + 17âŒ‰ rows tall (the properly-scaled values are written back to â€˜*ymaxâ€™ and â€˜*xmaxâ€™)."],["ncplane_reparent","Plane â€˜nâ€™ will be unbound from its parent plane, and will be made a bound child of â€˜newparentâ€™. It is an error if â€˜nâ€™ or â€˜newparentâ€™ are NULL. If â€˜newparentâ€™ is equal to â€˜nâ€™, â€˜nâ€™ becomes the root of a new pile, unless â€˜nâ€™ is already the root of a pile, in which case this is a no-op. Returns â€˜nâ€™. The standard plane cannot be reparented. Any planes bound to â€˜nâ€™ are reparented to the previous parent of â€˜nâ€™."],["ncplane_reparent_family","The same as ncplane_reparent(), except any planes bound to â€˜nâ€™ come along with it to its new destination. Their z-order is maintained. If â€˜newparentâ€™ is an ancestor of â€˜nâ€™, NULL is returned, and no changes are made."],["ncplane_resize","Resize the specified ncplane. The four parameters â€˜keepyâ€™, â€˜keepxâ€™, â€˜keeplenyâ€™, and â€˜keeplenxâ€™ define a subset of the ncplane to keep, unchanged. This may be a section of size 0, though none of these four parameters may be negative. â€˜keepxâ€™ and â€˜keepyâ€™ are relative to the ncplane. They must specify a coordinate within the ncplaneâ€™s totality. â€˜yoffâ€™ and â€˜xoffâ€™ are relative to â€˜keepyâ€™ and â€˜keepxâ€™, and place the upper-left corner of the resized ncplane. Finally, â€˜ylenâ€™ and â€˜xlenâ€™ are the dimensions of the ncplane after resizing. â€˜ylenâ€™ must be greater than or equal to â€˜keeplenyâ€™, and â€˜xlenâ€™ must be greater than or equal to â€˜keeplenxâ€™. It is an error to attempt to resize the standard plane. If either of â€˜keeplenyâ€™ or â€˜keeplenxâ€™ is non-zero, both must be non-zero."],["ncplane_resize_marginalized","Suitable for use as a â€˜resizecbâ€™ with planes created with NCPLANE_OPTION_MARGINALIZED. This will resize the plane â€˜nâ€™ against its parent, attempting to enforce the supplied margins."],["ncplane_resize_maximize","Suitable for use as a â€˜resizecbâ€™, this will resize the plane to the visual regionâ€™s size. It is used for the standard plane."],["ncplane_resize_realign","Suitable for use as a â€˜resizecbâ€™. This will realign the plane â€˜nâ€™ against its parent, using the alignment specified at ncplane_create()-time."],["ncplane_resizecb","Returns the ncplaneâ€™s current resize callback."],["ncplane_rotate_ccw",""],["ncplane_rotate_cw","Rotate the plane Ï€/2 radians clockwise or counterclockwise. This cannot be performed on arbitrary planes, because glyphs cannot be arbitrarily rotated. The glyphs which can be rotated are limited: line-drawing characters, spaces, half blocks, and full blocks. The plane must have an even number of columns. Use the ncvisual rotation for a more flexible approach."],["ncplane_scrolling_p",""],["ncplane_scrollup","Effect |r| scroll events on the plane |n|. Returns an error if |n| is not a scrolling plane, and otherwise returns the number of lines scrolled."],["ncplane_scrollup_child","Scroll |n| up until |child| is no longer hidden beneath it. Returns an error if |child| is not a child of |n|, or |n| is not scrolling, or |child| is fixed. Returns the number of scrolling events otherwise (might be 0)."],["ncplane_set_base","Set the ncplaneâ€™s base nccell. It will be used for purposes of rendering anywhere that the ncplaneâ€™s gcluster is 0. Note that the base cell is not affected by ncplane_erase(). â€˜egcâ€™ must be an extended grapheme cluster. Returns the number of bytes copied out of â€˜gclusterâ€™, or -1 on failure."],["ncplane_set_base_cell","Set the ncplaneâ€™s base nccell to â€˜câ€™. The base cell is used for purposes of rendering anywhere that the ncplaneâ€™s gcluster is 0. Note that the base cell is not affected by ncplane_erase(). â€˜câ€™ must not be a secondary cell from a multicolumn EGC."],["ncplane_set_bchannel",""],["ncplane_set_bg_alpha",""],["ncplane_set_bg_default",""],["ncplane_set_bg_palindex",""],["ncplane_set_bg_rgb",""],["ncplane_set_bg_rgb8",""],["ncplane_set_bg_rgb8_clipped","Same, but clipped to [0..255]."],["ncplane_set_channels",""],["ncplane_set_fchannel","Set an entire 32-bit channel of the plane"],["ncplane_set_fg_alpha","Set the alpha parameters for ncplane â€˜nâ€™."],["ncplane_set_fg_default","Use the default color for the foreground/background."],["ncplane_set_fg_palindex","Set the ncplaneâ€™s foreground palette index, set the foreground palette index bit, set it foreground-opaque, and clear the foreground default color bit."],["ncplane_set_fg_rgb","Same, but with rgb assembled into a channel (i.e. lower 24 bits)."],["ncplane_set_fg_rgb8","Set the current fore/background color using RGB specifications. If the terminal does not support directly-specified 3x8b cells (24-bit â€œTrueColorâ€, indicated by the â€œRGBâ€ terminfo capability), the provided values will be interpreted in some lossy fashion. None of r, g, or b may exceed 255. â€œHP-likeâ€ terminals require setting foreground and background at the same time using â€œcolor pairsâ€; Notcurses will manage color pairs transparently."],["ncplane_set_fg_rgb8_clipped",""],["ncplane_set_resizecb","Replace the ncplaneâ€™s existing resizecb with â€˜resizecbâ€™ (which may be NULL). The standard planeâ€™s resizecb may not be changed."],["ncplane_set_scrolling","All planes are created with scrolling disabled. Scrolling can be dynamically controlled with ncplane_set_scrolling(). Returns true if scrolling was previously enabled, or false if it was disabled."],["ncplane_set_styles","Set the specified style bits for the ncplane â€˜nâ€™, whether theyâ€™re actively supported or not."],["ncplane_set_userptr","Manipulate the opaque user pointer associated with this plane. ncplane_set_userptr() returns the previous userptr after replacing it with â€˜opaqueâ€™. the others simply return the userptr."],["ncplane_stain","Set the given channels throughout the specified region, keeping content and attributes unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_styles","Return the current styling for this ncplane."],["ncplane_styles_off",""],["ncplane_styles_on",""],["ncplane_styles_set",""],["ncplane_translate","provided a coordinate relative to the origin of â€˜srcâ€™, map it to the same absolute coordinate relative to the origin of â€˜dstâ€™. either or both of â€˜yâ€™ and â€˜xâ€™ may be NULL. if â€˜dstâ€™ is NULL, it is taken to be the standard plane."],["ncplane_translate_abs","Fed absolute â€˜yâ€™/â€˜xâ€™ coordinates, determine whether that coordinate is within the ncplane â€˜nâ€™. If not, return false. If so, return true. Either way, translate the absolute coordinates relative to â€˜nâ€™. If the point is not within â€˜nâ€™, these coordinates will not be within the dimensions of the plane."],["ncplane_userptr",""],["ncplane_vline_interp",""],["ncplane_vprintf_aligned","The ncplane equivalents of printf(3) and vprintf(3)."],["ncplane_vprintf_stained",""],["ncplane_vprintf_yx",""],["ncplane_x",""],["ncplane_y",""],["ncplane_yx","Get the origin of plane â€˜nâ€™ relative to its bound plane, or pile (if â€˜nâ€™ is a root plane). To get absolute coordinates, use ncplane_abs_yx()."],["ncprogbar_create","Takes ownership of the ncplane â€˜nâ€™, which will be destroyed by ncprogbar_destroy(). The progress bar is initially at 0%."],["ncprogbar_destroy","Destroy the progress bar and its underlying ncplane."],["ncprogbar_plane","Return a reference to the ncprogbarâ€™s underlying ncplane."],["ncprogbar_progress","Get the progress barâ€™s completion, a double on [0, 1]."],["ncprogbar_set_progress","Set the progress barâ€™s completion, a double 0 <= â€˜pâ€™ <= 1."],["ncreader_clear","empty the ncreader of any user input, and home the cursor."],["ncreader_contents","return a heap-allocated copy of the current (UTF-8) contents."],["ncreader_create","ncreaders provide freeform input in a (possibly multiline) region, supporting optional readline keybindings. takes ownership of â€˜nâ€™, destroying it on any error (ncreader_destroy() otherwise destroys the ncplane)."],["ncreader_destroy","destroy the reader and its bound plane. if â€˜contentsâ€™ is not NULL, the UTF-8 input will be heap-duplicated and written to â€˜contentsâ€™."],["ncreader_move_down",""],["ncreader_move_left","Atttempt to move in the specified direction. Returns 0 if a move was successfully executed, -1 otherwise. Scrolling is taken into account."],["ncreader_move_right",""],["ncreader_move_up",""],["ncreader_offer_input","Offer the input to the ncreader. If itâ€™s relevant, this function returns true, and the input ought not be processed further. Almost all inputs are relevant to an ncreader, save synthesized ones."],["ncreader_plane",""],["ncreader_write_egc","Destructively write the provided EGC to the current cursor location. Move the cursor as necessary, scrolling if applicable."],["ncreel_add","Add a new nctablet to the provided ncreel â€˜nrâ€™, having the callback object â€˜opaqueâ€™. Neither, either, or both of â€˜afterâ€™ and â€˜beforeâ€™ may be specified. If neither is specified, the new tablet can be added anywhere on the reel. If one or the other is specified, the tablet will be added before or after the specified tablet. If both are specified, the tablet will be added to the resulting location, assuming it is valid (after->next == before->prev); if it is not valid, or there is any other error, NULL will be returned."],["ncreel_create","Take over the ncplane â€˜ncâ€™ and use it to draw a reel according to â€˜poptsâ€™. The plane will be destroyed by ncreel_destroy(); this transfers ownership."],["ncreel_del","Delete the tablet specified by t from the ncreel â€˜nrâ€™. Returns -1 if the tablet cannot be found."],["ncreel_destroy","Destroy an ncreel allocated with ncreel_create()."],["ncreel_focused","Return the focused tablet, if any tablets are present. This is not a copy; be careful to use it only for the duration of a critical section."],["ncreel_next","Change focus to the next tablet, if one exists"],["ncreel_offer_input","Offer input â€˜niâ€™ to the ncreel â€˜nrâ€™. If itâ€™s relevant, this function returns true, and the input ought not be processed further. If itâ€™s irrelevant to the reel, false is returned. Relevant inputs include:"],["ncreel_plane","Returns the ncplane on which this ncreel lives."],["ncreel_prev","Change focus to the previous tablet, if one exists"],["ncreel_redraw","Redraw the ncreel â€˜nrâ€™ in its entirety. The reel will be cleared, and tablets will be lain out, using the focused tablet as a fulcrum. Tablet drawing callbacks will be invoked for each visible tablet."],["ncreel_tabletcount","Return the number of nctablets in the ncreel â€˜nrâ€™."],["ncselector_additem","Dynamically add or delete items. It is usually sufficient to supply a static list of items via ncselector_options->items."],["ncselector_create",""],["ncselector_delitem",""],["ncselector_destroy","Destroy the ncselector. If â€˜itemâ€™ is not NULL, the last selected option will be strdup()ed and assigned to â€˜*itemâ€™ (and must be free()d by the caller)."],["ncselector_nextitem",""],["ncselector_offer_input","Offer the input to the ncselector. If itâ€™s relevant, this function returns true, and the input ought not be processed further. If itâ€™s irrelevant to the selector, false is returned. Relevant inputs include:"],["ncselector_plane","Return a reference to the ncselectorâ€™s underlying ncplane."],["ncselector_previtem","Move up or down in the list. A reference to the newly-selected item is returned, or NULL if there are no items in the list."],["ncselector_selected","Return reference to the selected option, or NULL if there are no items."],["ncstrwidth","Returns the number of columns occupied by a multibyte (UTF-8) string, or -1 if a non-printable/illegal character is encountered."],["ncsubproc_createv","see exec(2). p-types use $PATH. e-type passes environment vars."],["ncsubproc_createvp",""],["ncsubproc_createvpe",""],["ncsubproc_destroy",""],["ncsubproc_plane",""],["nctab_cb","Returns the tab callback."],["nctab_move","Move â€˜tâ€™ after â€˜afterâ€™ (if not NULL) and before â€˜beforeâ€™ (if not NULL). If both â€˜afterâ€™ and â€˜beforeâ€™ are NULL, the function returns -1, otherwise it returns 0."],["nctab_move_left","Move â€˜tâ€™ to the right by one tab, looping around to become the last tab if needed."],["nctab_move_right","Move â€˜tâ€™ to the right by one tab, looping around to become leftmost if needed."],["nctab_name","Returns the tab name. This is not a copy and it should not be stored."],["nctab_name_width","Returns the width (in columns) of the tabâ€™s name."],["nctab_next","Returns the tab to the right of â€˜tâ€™. This does not change which tab is selected."],["nctab_prev","Returns the tab to the left of â€˜tâ€™. This does not change which tab is selected."],["nctab_set_cb","Set the tab callback function for â€˜tâ€™. Returns the previous tab callback."],["nctab_set_name","Change the name of â€˜tâ€™. Returns -1 if â€˜newnameâ€™ is NULL, and 0 otherwise."],["nctab_set_userptr","Set the user pointer of â€˜tâ€™. Returns the previous user pointer."],["nctab_userptr","Returns the tabâ€™s user pointer."],["nctabbed_add","Add a new tab to â€˜ntâ€™ with the given tab callback, name, and user pointer. If both â€˜beforeâ€™ and â€˜afterâ€™ are NULL, the tab is inserted after the selected tab. Otherwise, it gets put after â€˜afterâ€™ (if not NULL) and before â€˜beforeâ€™ (if not NULL). If both â€˜afterâ€™ and â€˜beforeâ€™ are given, they must be two neighboring tabs (the tab list is circular, so the last tab is immediately before the leftmost tab), otherwise the function returns NULL. If â€˜nameâ€™ is NULL or a string containing illegal characters, the function returns NULL. On all other failures the function also returns NULL. If it returns NULL, none of the arguments are modified, and the widget state is not altered."],["nctabbed_channels","Write the channels for tab headers, the selected tab header, and the separator to â€˜*hdrchanâ€™, â€˜*selchanâ€™, and â€˜*sepchanâ€™ respectively."],["nctabbed_content_plane","Returns the tab content plane."],["nctabbed_create","Creates a new nctabbed widget, associated with the given ncplane â€˜nâ€™, and with additional options given in â€˜optsâ€™. When â€˜optsâ€™ is NULL, it acts as if it were called with an all-zero opts. The widget takes ownership of â€˜nâ€™, and destroys it when the widget is destroyed. Returns the newly created widget. Returns NULL on failure, also destroying â€˜nâ€™."],["nctabbed_del","Remove a tab â€˜tâ€™ from â€˜ntâ€™. Its neighboring tabs become neighbors to each other. If â€˜tâ€™ if the selected tab, the tab after â€˜tâ€™ becomes selected. Likewise if â€˜tâ€™ is the leftmost tab, the tab after â€˜tâ€™ becomes leftmost. If â€˜tâ€™ is the only tab, there will no more be a selected or leftmost tab, until a new tab is added. Returns -1 if â€˜tâ€™ is NULL, and 0 otherwise."],["nctabbed_destroy","Destroy an nctabbed widget. All memory belonging to â€˜ntâ€™ is deallocated, including all tabs and their names. The plane associated with â€˜ntâ€™ is also destroyed. Calling this with NULL does nothing."],["nctabbed_ensure_selected_header_visible","Make sure the tab header of the currently selected tab is at least partially visible. (by rotating tabs until at least one column is displayed) Does nothing if there are no tabs."],["nctabbed_leftmost","Returns the leftmost tab, or NULL if there are no tabs."],["nctabbed_next","Select the tab after the currently selected tab, and return the newly selected tab. Returns NULL if there are no tabs."],["nctabbed_plane","Returns the plane associated to â€˜ntâ€™."],["nctabbed_prev","Select the tab before the currently selected tab, and return the newly selected tab. Returns NULL if there are no tabs."],["nctabbed_redraw","Redraw the widget. This calls the tab callback of the currently selected tab to draw tab contents, and draws tab headers. The tab content plane is not modified by this function, apart from resizing the plane is necessary."],["nctabbed_rotate","Rotate the tabs of â€˜ntâ€™ right by â€˜amtâ€™ tabs, or â€˜-amtâ€™ tabs left if â€˜amtâ€™ is negative. Tabs are rotated only by changing the leftmost tab; the selected tab stays the same. If there are no tabs, nothing happens."],["nctabbed_select","Change the selected tab to be â€˜tâ€™. Returns the previously selected tab."],["nctabbed_selected","Returns the currently selected tab, or NULL if there are no tabs."],["nctabbed_separator","Returns the tab separator. This is not a copy and it should not be stored. This can be NULL, if the separator was set to NULL in ncatbbed_create() or nctabbed_set_separator()."],["nctabbed_separator_width","Returns the tab separator width, or zero if there is no separator."],["nctabbed_set_hdrchan","Set the tab headers channel for â€˜ntâ€™."],["nctabbed_set_selchan","Set the selected tab header channel for â€˜ntâ€™."],["nctabbed_set_separator","Change the tab separator for â€˜ntâ€™. Returns -1 if â€˜separatorâ€™ is not NULL and is not a valid string, and 0 otherwise."],["nctabbed_set_sepchan","Set the tab separator channel for â€˜ntâ€™."],["nctabbed_tabcount","Returns the number of tabs in the widget."],["nctablet_ncplane","Deprecated form of nctablet_plane()."],["nctablet_plane","Access the ncplane associated with nctablet â€˜tâ€™, if one exists."],["nctablet_userptr","Returns a pointer to a user pointer associated with this nctablet."],["nctree_create","|opts| may not be NULL, since it is necessary to define a callback function."],["nctree_destroy","Destroy the nctree."],["nctree_focused","Return the focused item, if any items are present. This is not a copy; be careful to use it only for the duration of a critical section."],["nctree_goto","Go to the item specified by the array |spec|, terminated by UINT_MAX. If the spec is invalid, NULL is returned, and the depth of the first invalid spec is written to *|failspec|. Otherwise, the true depth is written to *|failspec|, and the curry is returned (|failspec| is necessary because the curry could itself be NULL)."],["nctree_next","Change focus to the next item."],["nctree_offer_input","Offer input â€˜niâ€™ to the nctree â€˜nâ€™. If itâ€™s relevant, this function returns true, and the input ought not be processed further. If itâ€™s irrelevant to the tree, false is returned. Relevant inputs include:"],["nctree_plane","Returns the ncplane on which this nctree lives."],["nctree_prev","Change focus to the previous item."],["nctree_redraw","Redraw the nctree â€˜nâ€™ in its entirety. The tree will be cleared, and items will be lain out, using the focused item as a fulcrum. Item-drawing callbacks will be invoked for each visible item."],["ncuplot_add_sample","Add to or set the value corresponding to this x. If x is beyond the current x window, the x window is advanced to include x, and values passing beyond the window are lost. The first call will place the initial window. The plot will be redrawn, but notcurses_render() is not called."],["ncuplot_create","Use the provided plane â€˜nâ€™ for plotting according to the options â€˜optsâ€™. The plot will make free use of the entirety of the plane. For domain autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while ncdplot holds doubles."],["ncuplot_destroy",""],["ncuplot_plane","Return a reference to the ncplotâ€™s underlying ncplane."],["ncuplot_sample",""],["ncuplot_set_sample",""],["ncvisual_at_yx","Get the specified pixel from the specified ncvisual."],["ncvisual_blitter_geom","Get the size and ratio of ncvisual pixels to output cells along the y and x axes. The input size (in pixels) will be written to â€˜yâ€™ and â€˜xâ€™. The scaling will be written to â€˜scaleyâ€™ and â€˜scalexâ€™. With these: rows = (y / scaley) + !!(y % scaley) or (y + scaley - 1) / scaley cols = (x / scalex) + !!(x % scalex) or (x + scalex - 1) / scalex Returns non-zero for an invalid â€˜voptsâ€™. The blitter that will be used is returned in â€˜*blitterâ€™."],["ncvisual_decode","extract the next frame from an ncvisual. returns 1 on end of file, 0 on success, and -1 on failure."],["ncvisual_decode_loop","decode the next frame ala ncvisual_decode(), but if we have reached the end, rewind to the first frame of the ncvisual. a subsequent â€˜ncvisual_render()â€™ will render the first frame, as if the ncvisual had been closed and reopened. the return values remain the same as those of ncvisual_decode()."],["ncvisual_destroy","Destroy an ncvisual. Rendered elements will not be disrupted, but the visual can be neither decoded nor rendered any further."],["ncvisual_from_bgra","ncvisual_from_rgba(), but â€˜bgraâ€™ is arranged as BGRA. note that this is a byte-oriented layout, despite being bunched in 32-bit pixels; the lowest memory address ought be B, and A is reached by adding 3 to that address."],["ncvisual_from_file","Open a visual at â€˜fileâ€™, extract a codec and parameters, decode the first image to memory."],["ncvisual_from_palidx","ncvisual_from_rgba(), but â€˜dataâ€™ is â€˜pstrideâ€™-byte palette-indexed pixels, arranged in â€˜rowsâ€™ lines of â€˜rowstrideâ€™ bytes each, composed of â€˜colsâ€™ pixels. â€˜paletteâ€™ is an array of at least â€˜palsizeâ€™ ncchannels."],["ncvisual_from_plane","Promote an ncplane â€˜nâ€™ to an ncvisual. The plane may contain only spaces, half blocks, and full blocks. The latter will be checked, and any other glyph will result in a NULL being returned. This function exists so that planes can be subjected to ncvisual transformations. If possible, itâ€™s better to create the ncvisual from memory using ncvisual_from_rgba()."],["ncvisual_from_rgb_loose","ncvisual_from_rgba(), but the pixels are 4-byte RGBx. A is filled in throughout using â€˜alphaâ€™. rowstride must be a multiple of 4."],["ncvisual_from_rgb_packed","ncvisual_from_rgba(), but the pixels are 3-byte RGB. A is filled in throughout using â€˜alphaâ€™."],["ncvisual_from_rgba","Prepare an ncvisual, and its underlying plane, based off RGBA content in memory at â€˜rgbaâ€™. â€˜rgbaâ€™ is laid out as â€˜rowsâ€™ lines, each of which is â€˜rowstrideâ€™ bytes in length. Each line has â€˜colsâ€™ 32-bit 8bpc RGBA pixels followed by possible padding (there will be â€˜rowstrideâ€™ - â€˜colsâ€™ * 4 bytes of padding). The total size of â€˜rgbaâ€™ is thus (rows * rowstride) bytes, of which (rows * cols * 4) bytes are actual non-padding data."],["ncvisual_inflate","Inflate each pixel in the image to â€˜scaleâ€™xâ€™scaleâ€™ pixels. It is an error if â€˜scaleâ€™ is less than 1. The original color is retained. Deprecated; use ncvisual_resize_noninterpolative(), which this now wraps."],["ncvisual_media_defblitter","Get the default media (not plot) blitter for this environment when using the specified scaling method. Currently, this means:"],["ncvisual_polyfill_yx","Polyfill at the specified location within the ncvisual â€˜nâ€™, using â€˜rgbaâ€™."],["ncvisual_render","Render the decoded frame to the specified ncplane. If one is not provided, one will be created, having the exact size necessary to display the visual. A subregion of the visual can be rendered using â€˜begxâ€™, â€˜begyâ€™, â€˜lenxâ€™, and â€˜lenyâ€™. Negative values for â€˜begyâ€™ or â€˜begxâ€™ are an error. It is an error to specify any region beyond the boundaries of the frame. Returns the (possibly newly-created) plane to which we drew."],["ncvisual_resize","Scale the visual to â€˜rowsâ€™ X â€˜columnsâ€™ pixels, using the best scheme available. This is a lossy transformation, unless the size is unchanged."],["ncvisual_resize_noninterpolative","Scale the visual to â€˜rowsâ€™ X â€˜columnsâ€™ pixels, using non-interpolative (naive) scaling. No new colors will be introduced as a result."],["ncvisual_rotate","Rotate the visual â€˜radsâ€™ radians. Only M_PI/2 and -M_PI/2 are supported at the moment, but this will change FIXME."],["ncvisual_set_yx","Set the specified pixel in the specified ncvisual."],["ncvisual_simple_streamer","Shut up and display my frames! Provide as an argument to ncvisual_stream(). If youâ€™d like subtitles to be decoded, provide an ncplane as the curry. If the curry is NULL, subtitles will not be displayed."],["ncvisual_stream","Stream the entirety of the media, according to its own timing. Blocking, obviously. streamer may be NULL; it is otherwise called for each frame, and its return value handled as outlined for streamcb. If streamer() returns non-zero, the stream is aborted, and that value is returned. By convention, return a positive number to indicate intentional abort from within streamer(). â€˜timescaleâ€™ allows the frame duration time to be scaled. For a visual naturally running at 30FPS, a â€˜timescaleâ€™ of 0.1 will result in 300FPS, and a â€˜timescaleâ€™ of 10 will result in 3FPS. It is an error to supply â€˜timescaleâ€™ less than or equal to 0."],["ncvisual_subtitle",""],["ncvisual_subtitle_plane","If a subtitle ought be displayed at this time, return a new plane (bound to â€˜parentâ€™ containing the subtitle, which might be text or graphics (depending on the input format)."],["notcurses_accountname","Returns a heap-allocated copy of the user name under which we are running."],["notcurses_at_yx","Retrieve the contents of the specified cell as last rendered. Returns the EGC or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to â€˜stylemaskâ€™ and â€˜channelsâ€™, respectively."],["notcurses_bottom","Return the bottommost ncplane of the standard pile."],["notcurses_canbraille","Can we reliably use Unicode Braille?"],["notcurses_canchangecolor",""],["notcurses_canfade","Can we fade? Fading requires either the â€œrgbâ€ or â€œcccâ€ terminfo capability."],["notcurses_canhalfblock","Can we reliably use Unicode halfblocks?"],["notcurses_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["notcurses_canopen_videos","Can we load videos? This requires being built against FFmpeg."],["notcurses_canquadrant","Can we reliably use Unicode quadrants?"],["notcurses_cansextant","Can we reliably use Unicode 13 sextants?"],["notcurses_cantruecolor","Can we directly specify RGB values per cell, or only use palettes?"],["notcurses_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["notcurses_check_pixel_support","Can we blit pixel-accurate bitmaps?"],["notcurses_core_init","The same as notcurses_init(), but without any multimedia functionality, allowing for a svelter binary. Link with notcurses-core if this is used."],["notcurses_cursor_disable","Disable the hardware cursor. It is an error to call this while the cursor is already disabled."],["notcurses_cursor_enable","Enable or disable the terminalâ€™s cursor, if supported, placing it at â€˜yâ€™, â€˜xâ€™. Immediate effect (no need for a call to notcurses_render()). It is an error if â€˜yâ€™, â€˜xâ€™ lies outside the standard plane. Can be called while already visible to move the cursor."],["notcurses_cursor_yx","Get the current location of the terminalâ€™s cursor, whether visible or not."],["notcurses_debug","Dump selected Notcurses state to the supplied â€˜debugfpâ€™. Output is freeform, newline-delimited, and subject to change. It includes geometry of all planes, from all piles. No line has more than 80 columnsâ€™ worth of output."],["notcurses_debug_caps",""],["notcurses_detected_terminal","Returns the name (and sometimes version) of the terminal, as Notcurses has been best able to determine."],["notcurses_drop_planes","Destroy all ncplanes other than the stdplane."],["notcurses_enter_alternate_screen","Shift to the alternate screen, if available. If already using the alternate screen, this returns 0 immediately. If the alternate screen is not available, this returns -1 immediately. Entering the alternate screen turns off scrolling for the standard plane."],["notcurses_get","Read a UTF-32-encoded Unicode codepoint from input. This might only be part of a larger EGC. Provide a NULL â€˜tsâ€™ to block at length, and otherwise a timespec to bound blocking. Returns a single Unicode code point, or (uint32_t)-1 on error. â€˜sigmaskâ€™ may be NULL. Returns 0 on a timeout. If an event is processed, the return value is the â€˜idâ€™ field from that event. â€˜niâ€™ may be NULL."],["notcurses_getc","Backwards-compatibility wrapper; this will be removed for ABI3. Use notcurses_get() in new code."],["notcurses_hostname","Returns a heap-allocated copy of the local host name."],["notcurses_init","Initialize a Notcurses context on the connected terminal at â€˜fpâ€™. â€˜fpâ€™ must be a tty. Youâ€™ll usually want stdout. NULL can be supplied for â€˜fpâ€™, in which case /dev/tty will be opened. Returns NULL on error, including any failure initializing terminfo."],["notcurses_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call notcurses_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["notcurses_leave_alternate_screen","Exit the alternate screen. Immediately returns 0 if not currently using the alternate screen."],["notcurses_lex_blitter","Lex a blitter."],["notcurses_lex_margins","Lex a margin argument according to the standard Notcurses definition. There can be either a single number, which will define all margins equally, or there can be four numbers separated by commas."],["notcurses_lex_scalemode","Lex a scaling mode (one of â€œnoneâ€, â€œstretchâ€, â€œscaleâ€, â€œhiresâ€, â€œscalehiâ€, or â€œinflateâ€)."],["notcurses_linesigs_disable","Disable signals originating from the terminalâ€™s line discipline, i.e. SIGINT (^C), SIGQUIT (^), and SIGTSTP (^Z). They are enabled by default."],["notcurses_linesigs_enable","Restore signals originating from the terminalâ€™s line discipline, i.e. SIGINT (^C), SIGQUIT (^), and SIGTSTP (^Z), if disabled."],["notcurses_mouse_disable","Disable mouse events. Any events in the input queue can still be delivered."],["notcurses_mouse_enable","Enable the mouse in â€œbutton-event trackingâ€ mode with focus detection and UTF8-style extended coordinates. On failure, -1 is returned. On success, 0 is returned, and mouse events will be published to notcurses_get()."],["notcurses_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["notcurses_refresh","Refresh the physical screen to match what was last rendered (i.e., without reflecting any changes since the last call to notcurses_render()). This is primarily useful if the screen is externally corrupted, or if an NCKEY_RESIZE event has been read and youâ€™re not yet ready to render. The current screen geometry is returned in â€˜yâ€™ and â€˜xâ€™, if they are not NULL."],["notcurses_render","Renders and rasterizes the standard pile in one shot. Blocking call."],["notcurses_render_to_buffer",""],["notcurses_render_to_file",""],["notcurses_stats","Acquire an atomic snapshot of the Notcurses objectâ€™s stats."],["notcurses_stats_alloc","Allocate an ncstats object. Use this rather than allocating your own, since future versions of Notcurses might enlarge this structure."],["notcurses_stats_reset","Reset all cumulative stats (immediate ones, such as fbbytes, are not reset), first copying them into |*stats| (if |stats| is not NULL)."],["notcurses_stdplane","Get a reference to the standard plane (one matching our current idea of the terminal size) for this terminal. The standard plane always exists, and its origin is always at the uppermost, leftmost cell of the terminal."],["notcurses_stdplane_const",""],["notcurses_stop","Destroy a Notcurses context."],["notcurses_str_blitter","Get the name of a blitter."],["notcurses_str_scalemode","Get the name of a scaling mode."],["notcurses_supported_styles","Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only indicated as supported if the terminal can support it together with color. For more information, see the â€œncvâ€ capability in terminfo(5)."],["notcurses_top","Return the topmost ncplane of the standard pile."],["notcurses_ucs32_to_utf8","input functions like notcurses_get() return ucs32-encoded uint32_t. convert a series of uint32_t to utf8. result must be at least 4 bytes per input uint32_t (6 bytes per uint32_t will future-proof against Unicode expansion). the number of bytes used is returned, or -1 if passed illegal ucs32, or too small of a buffer."],["notcurses_version","Get a human-readable string describing the running Notcurses version."],["notcurses_version_components","Cannot be inline, as we want to get the versions of the actual Notcurses library we loaded, not what we compile against."],["sigaction","Get and/or set the action for signal SIG."],["sigaddset","Add SIGNO to SET."],["sigdelset","Remove SIGNO from SET."],["sigemptyset","Clear all signals from SET."],["sigfillset","Set all signals in SET."],["sigismember","Return 1 if SIGNO is in SET, 0 if not."],["signal",""],["sigpending","Put in SET all signals that are blocked and waiting to be delivered."],["sigprocmask","Get and/or change the set of blocked signals."],["sigsuspend","Change the set of blocked signals to SET, wait until a signal arrives, and restore the set of blocked signals."]],"static":[["__daylight",""],["__timezone",""],["__tzname",""],["daylight",""],["in6addr_any",""],["in6addr_loopback",""],["optarg",""],["opterr",""],["optind",""],["optopt",""],["stderr",""],["stdin",""],["stdout",""],["timezone",""],["tzname",""]],"struct":[["_G_fpos64_t","The tag name of this struct is _G_fpos64_t to preserve historic C++ mangled names for functions taking fpos_t and/or fpos64_t arguments.  That name should not be used in new code."],["_G_fpos_t","The tag name of this struct is _G_fpos_t to preserve historic C++ mangled names for functions taking fpos_t arguments. That name should not be used in new code."],["_IO_FILE","The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code."],["_IO_codecvt",""],["_IO_marker",""],["_IO_wide_data",""],["__IncompleteArrayField",""],["__fsid_t",""],["__mbstate_t","Conversion state information."],["__sigset_t",""],["__va_list_tag",""],["cmsghdr","Structure used for storage of ancillary data object information."],["div_t","Returned by `divâ€™."],["in6_addr","IPv6 address"],["in_addr",""],["iovec","Structure for scatter/gather I/O."],["ldiv_t",""],["linger","Structure used to manipulate the SO_LINGER option."],["lldiv_t","Returned by `lldivâ€™."],["nccapabilities","Capabilities, derived from terminfo, environment variables, and queries"],["nccell","An nccell corresponds to a single character cell on some plane, which can be occupied by a single grapheme cluster (some root spacing glyph, along with possible combining characters, which might span multiple columns). At any cell, we can have a theoretically arbitrarily long UTF-8 string, a foreground color, a background color, and an attribute set. Valid grapheme cluster contents include:"],["ncdirect",""],["ncdplot",""],["ncfadectx",""],["ncfdplane",""],["ncfdplane_options","read from an fd until EOF (or beyond, if follow is set), invoking the userâ€™s callback each time. runs in its own context. on EOF or error, the finalizer callback will be invoked, and the user ought destroy the ncfdplane. the data is not guaranteed to be nul-terminated, and may contain arbitrary zeroes."],["ncinput","An input event. Cell coordinates are currently defined only for mouse events."],["ncmenu",""],["ncmenu_item","Menus. Horizontal menu bars are supported, on the top and/or bottom rows. If the menu bar is longer than the screen, it will be only partially visible. Menus may be either visible or invisible by default. In the event of a plane resize, menus will be automatically moved/resized. Elements can be dynamically enabled or disabled at all levels (menu, section, and item),"],["ncmenu_options",""],["ncmenu_section",""],["ncmselector_item",""],["ncmultiselector",""],["ncmultiselector_options","multiselection widget â€“ a selector supporting multiple selections."],["ncpalette","Palette API. Some terminals only support 256 colors, but allow the full palette to be specified with arbitrary RGB colors. In all cases, itâ€™s more performant to use indexed colors, since itâ€™s much less data to write to the terminal. If you can limit yourself to 256 colors, thatâ€™s probably best."],["ncplane",""],["ncplane_options",""],["ncplot_options",""],["ncprogbar",""],["ncprogbar_options",""],["ncreader",""],["ncreader_options",""],["ncreel",""],["ncreel_options",""],["ncselector",""],["ncselector_item","selection widget â€“ an ncplane with a title header and a body section. the body section supports infinite scrolling up and down."],["ncselector_options",""],["ncstats","whenever a new field is added here, ensure we add the proper rule to notcurses_stats_reset(), so that values are preserved in the stash stats."],["ncsubproc",""],["ncsubproc_options",""],["nctab",""],["nctabbed",""],["nctabbed_options",""],["nctablet",""],["nctree",""],["nctree_item","each item has a curry, and zero or more subitems."],["nctree_options",""],["ncuplot",""],["ncvgeom","FIXME this ought be used in the rendered mode API as well; itâ€™s currently only used by direct mode. describes all geometries of an ncvisualâ€“both those which are inherent, and those in a given rendering regime. pixy and pixx are the true internal pixel geometry, taken directly from the load (and updated by ncvisual_resize()). cdimy/cdimx are the cell pixel geometry at the time of this call (it can change with a font change, in which case all values other than pixy/pixx are invalidated). rpixy/rpixx are the pixel geometry as handed to the blitter, following any scaling. scaley/scalex are the number of input pixels drawn to full cell; when using NCBLIT_PIXEL, they are equivalent to cdimy/cdimx. rcelly/rcellx are the cell geometry as written by the blitter, following any padding (there is padding whenever rpix{y, x} is not evenly divided by scale{y, x}, and also sometimes for Sixel). maxpixely/maxpixelx are defined only when NCBLIT_PIXEL is used, and specify the largest bitmap that the terminal is willing to accept."],["ncvisual",""],["ncvisual_options",""],["notcurses",""],["notcurses_options","Configuration for notcurses_init()."],["pollfd","Data structure describing a polling request."],["sigaction","Structure describing the action to be taken when a signal arrives."],["termios",""],["timespec","POSIX.1b structure for a time value.  This is like a `struct timevalâ€™ but has nanoseconds instead of microseconds."],["tm","ISO C `broken-down timeâ€™ structure."]],"type":[["FILE","The opaque type of streams.  This is the definition used elsewhere."],["_Float32",""],["_Float32x",""],["_Float64",""],["_Float64x",""],["_IO_lock_t",""],["__blkcnt64_t",""],["__blkcnt_t",""],["__blksize_t",""],["__builtin_va_list",""],["__caddr_t",""],["__clock_t",""],["__clockid_t",""],["__compar_fn_t",""],["__daddr_t",""],["__dev_t",""],["__fpos64_t","The tag name of this struct is _G_fpos64_t to preserve historic C++ mangled names for functions taking fpos_t and/or fpos64_t arguments.  That name should not be used in new code."],["__fpos_t","The tag name of this struct is _G_fpos_t to preserve historic C++ mangled names for functions taking fpos_t arguments. That name should not be used in new code."],["__fsblkcnt64_t",""],["__fsblkcnt_t",""],["__fsfilcnt64_t",""],["__fsfilcnt_t",""],["__fsword_t",""],["__gid_t",""],["__gnuc_va_list",""],["__id_t",""],["__ino64_t",""],["__ino_t",""],["__int16_t",""],["__int32_t",""],["__int64_t",""],["__int8_t","Fixed-size types, underlying types depend on word size and compiler."],["__int_least16_t",""],["__int_least32_t",""],["__int_least64_t",""],["__int_least8_t","Smallest types with at least a given width."],["__intmax_t",""],["__intptr_t",""],["__key_t",""],["__loff_t","These few donâ€™t really vary by system, they always correspond to one of the other defined types."],["__mode_t",""],["__nlink_t",""],["__off64_t",""],["__off_t",""],["__pid_t",""],["__quad_t",""],["__rlim64_t",""],["__rlim_t",""],["__sig_atomic_t","C99: An integer type that can be accessed as an atomic entity, even in the presence of asynchronous interrupts. It is not currently necessary for this to be machine-specific."],["__sighandler_t","Type of a signal handler."],["__socket_type","Types of sockets."],["__socklen_t",""],["__ssize_t",""],["__suseconds_t",""],["__syscall_slong_t",""],["__syscall_ulong_t",""],["__time_t",""],["__timer_t",""],["__u_char","Convenience types."],["__u_int",""],["__u_long",""],["__u_quad_t",""],["__u_short",""],["__uid_t",""],["__uint16_t",""],["__uint32_t",""],["__uint64_t",""],["__uint8_t",""],["__uint_least16_t",""],["__uint_least32_t",""],["__uint_least64_t",""],["__uint_least8_t",""],["__uintmax_t",""],["__useconds_t",""],["blkcnt_t",""],["cc_t",""],["cell",""],["clock_t","Returned by `clockâ€™."],["clockid_t","Clock ID used in clock and timer functions."],["dev_t",""],["fadecb","Called for each fade iteration on â€˜ncpâ€™. If anything but 0 is returned, the fading operation ceases immediately, and that value is propagated out. The recommended absolute display time target is passed in â€˜tspecâ€™."],["fpos_t",""],["fsblkcnt_t",""],["fsfilcnt_t",""],["gid_t",""],["id_t",""],["in_addr_t","Internet address."],["in_port_t","Type to represent a port."],["ino_t",""],["int_fast16_t",""],["int_fast32_t",""],["int_fast64_t",""],["int_fast8_t","Signed."],["int_least16_t",""],["int_least32_t",""],["int_least64_t",""],["int_least8_t","Signed."],["intmax_t","Largest integral types."],["key_t",""],["ncalign_e","Alignment within a plane or terminal. Left/right-justified, or centered."],["ncblitter_e","we never blit full blocks, but instead spaces (more efficient) with the background set to the desired foreground. these need be kept in the same order as the blitters[] definition in lib/blit.c."],["ncdirectf",""],["ncdirectv",""],["ncfdplane_callback",""],["ncfdplane_done_cb",""],["ncloglevel_e","These log levels consciously map cleanly to those of libav; Notcurses itself does not use this full granularity. The log level does not affect the opening and closing banners, which can be disabled via the notcurses_option structâ€™s â€˜suppress_bannerâ€™. Note that if stderr is connected to the same terminal on which weâ€™re rendering, any kind of logging will disrupt the output (which is undesirable). The â€œdefaultâ€ zero value is NCLOGLEVEL_PANIC."],["ncscale_e","How to scale an ncvisual during rendering. NCSCALE_NONE will apply no scaling. NCSCALE_SCALE scales a visual to the planeâ€™s size, maintaining aspect ratio. NCSCALE_STRETCH stretches and scales the image in an attempt to fill the entirety of the plane. NCSCALE_NONE_HIRES and NCSCALE_SCALE_HIRES behave like their counterparts, but admit blitters which donâ€™t preserve aspect ratio."],["ncstreamcb","Called for each frame rendered from â€˜ncvâ€™. If anything but 0 is returned, the streaming operation ceases immediately, and that value is propagated out. The recommended absolute display time target is passed in â€˜tspecâ€™."],["nfds_t","Type used for the number of file descriptors."],["nlink_t",""],["off_t",""],["pid_t",""],["register_t",""],["sa_family_t","POSIX.1g specifies this type name for the `sa_familyâ€™ member."],["sig_atomic_t","An integral type that can be modified atomically, without the possibility of a signal arriving in the middle of the operation."],["sigset_t","A set of signals to be blocked, unblocked, or waited for."],["size_t",""],["speed_t",""],["ssize_t",""],["suseconds_t",""],["tabcb","Tab content drawing callback. Takes the tab it was associated to, the ncplane on which tab content is to be drawn, and the user pointer of the tab. It is called during nctabbed_redraw()."],["tabletcb","Tablet draw callback, provided a tablet (from which the ncplane and userptr may be extracted), and a bool indicating whether output ought be drawn from the top (true) or bottom (false). Returns non-negative count of output lines, which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."],["tcflag_t",""],["time_t","Returned by `timeâ€™."],["timer_t","Timer ID returned by `timer_createâ€™."],["u_int16_t",""],["u_int32_t",""],["u_int64_t",""],["u_int8_t","These were defined by ISO C without the first `_â€™."],["uid_t",""],["uint_fast16_t",""],["uint_fast32_t",""],["uint_fast64_t",""],["uint_fast8_t","Unsigned."],["uint_least16_t",""],["uint_least32_t",""],["uint_least64_t",""],["uint_least8_t","Unsigned."],["uintmax_t",""],["useconds_t",""],["va_list",""],["wchar_t",""],["wctype_t","Scalar type that can hold values which represent locale-specific character classifications."],["wint_t",""]],"union":[["__mbstate_t__bindgen_ty_1",""],["in6_addr__bindgen_ty_1",""]]});